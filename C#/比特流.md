## BitTorrent



## BEncoding

让我们打开这个之前在记事本中创建的种子文件

```c#
d8:announce33:http://192.168.1.74:6969/announce7:comment17:Comment goes here10:created by25:Transmission/2.92 (14714)13:creation datei1460444420e8:encoding5:UTF-84:infod6:lengthi59616e4:name9:lorem.txt12:piece lengthi32768e6:pieces40:L@fR���3�K*Ez�>_YS��86��"�&�p�<�6�C{�9G7:privatei0eeexxxxxxxxxx d8:announce33:http://192.168.1.74:6969/announce7:comment17:Comment goes here10:created by25:Transmission/2.92 (14714)13:creation datei1460444420e8:encoding5:UTF-84:infod6:lengthi59616e4:name9:lorem.txt12:piece lengthi32768e6:pieces40:L@fR���3�K*Ez�>_YS��86��"�&�p�<�6�C{�9G7:privatei0eeeC

```

看起来很杂乱

## 解码

### 数字

如果知道下一个对象是数字，就遍历数组直到找到代表数字结尾的字母(e)，把这个过程中的bytes记录下来，然后我们把这些bytes先转化为string再转换为long。使用long的原因是因为有些数字代表文件的字节数，可能会大于int的最大值。

### 字符串

对于字符串，我们需要解析两个都独立的部分，第一个部分是标识字节数组长度的数字，第二部分是字节本身。因此首先，就遍历数组直到找到代表数字结尾的字母。在此使用do...while因为需要第一个字符。然后和解码数字过程一样，我们把这些bytes先转化为string再转换为int来得到长度。这个长度代表数组中有多少字节，我们可以遍历数组直到拿到所有字节。

### 链表

对于链表，我们简单的抓取下一个对象直到遇到结尾字符。我们不需要知道链表中的对象类型是什么，只需要将它们装进去。规范没有指定它们的所有项是否都是相同的类型，在我们的引用中，无需检查。

### 字典

字典采用同样的处理方法，唯一的不同支持就是，我们一次取出两个对象（一个key，一个value）然后把他们写入字典中，key必须是合法的UTF-8的字符串。

字典中的项必须按照key中的原始UTF-8字节排序  。这对于我们检查传入字典是否正确排序很重要，因为我们之后需要反转解码的过程并生成与输入相同的输出。如果输入的字典没有正确的排序，我们将会失去错误排序部分的信息。

## 编码

现在，让我们反转这个过程，这样我们就可以用C#生成用BEncoded格式的输出。我们准备使用MemoryStream来生产字节数组。使用EncodeNextObject()方法来鉴别当前对象的类型，并且调用相关的编码方法，这样我们就可以递归编码。

我们将会给MemorySream增加一些扩展，让生成的字节数组更加整洁。

### 数字

只有long类型的数字才能编码，简单的在其前面加一个i，然后将数字转化为UTF-8字符串，最后加上结尾字符e

### 字节数组&字符串

对于字节数组我们把数组长度转化为字符串，然后后面接一个a，然后接上数字本身。处理字符串的时候，先把字符串转化为字节数组，然后按同样的方式处理

### 链表

处理链表的方式很直接，我们添加初始的l，然后将其中每个元素编码，最后添加e。

### 字典

字典的处理也使用相似的方式，开头增加d，之后的每个键值对编码，最后加上e。在C#中，字典是不能排序的，在遍历Dictionary的时候，没有顺序的假设。因此我们把key排好序之后再遍历他们，获取他们的值。

## 种子

现在我们有了BEncoing解码器，我们现在回到之前的种子文件，然后把他解析为C#的数据格式

```C#
d
  8:announce            33:http://192.168.1.74:6969/announce
  7:comment             17:Comment goes here
  10:created by         25:Transmission/2.92 (14714)
  13:creation date      i1460444420e
  8:encoding            5:UTF-8
  4:info              
    d
      6:length          i59616e
      4:name            9:lorem.txt
      12:piece length   i32768e
      6:pieces          40:L@fR���3�K*Ez�>_YS��86��"�&�p�<�6�C{�9G
      7:private         i0e
    e
e
```

让我们一个个看看这些项并且决定如何存储

- announce：这个是我们需要追踪的url，可以是一个url也可以是一个url列表(List<Tracker>)
- comment：用户特殊的说明(string)
- created by：创建者(用户或者软件)(string)
- creation date：创建时间(DateTime)
- encoding：编码格式(System.Text.Encoding)
- info：我们希望分享的文件信息
  - length：文件按的大小(字节)(long)，一个种子可以包含一个或者多个文件，因此使用List<FileItem>
  - name：文件名(string)
  - piece length：文件块的大小(字节)通常是2的倍数(int)
  - pieces：由每一块生成的一个长度为20的SHA1字符串，连在一起变成一个大的字节数组(byte[][])
  - private：文件是否是私人的(bool)

## 数据结构

我们来创建一个简单的类来表示这些信息

上面有提到两个帮助的类，第一个是FileItem，它存储每个文件的路径、大小、偏移量(即这个文件之前的文件大小总和)

```c#
public class FileItem
{            
    public string Path;
    public long Size;
    public long Offset;

    public string FormattedSize { get { return Torrent.BytesToString(Size); } }
}
```

第二个帮助类是Tracker，用来保存url，我们之后会在这个类中加更多的功能以便和tracker保持通信。

```c#
public class Tracker
{
    public event EventHandler<List<IPEndPoint>> PeerListUpdated;

    public string Address { get; private set; }

    public Tracker(string address)
    {
        Address = address;
    }
}
```

### 哈希

种子文件还需要另一块数据，一般称之为哈希值。这是一个种子文件info部分的字节SHA1哈希，用来标识种子。我们也增添了一些其他属性用来把infohash转化为16进制字符以及通过HTTP与tracker通信的时候所需要的版本

```c#
public byte[] Infohash { get; private set; } = new byte[20];
public string HexStringInfohash { get { return String.Join("", this.Infohash.Select(x => x.ToString("x2"))); } }
public string UrlSafeStringInfohash { get { return Encoding.UTF8.GetString(WebUtility.UrlEncodeToBytes(this.Infohash, 0, 20)); } }
```

### 片&块

种子文件中的文件放在列表中，被拆分为相同大小的片（最后一块可能会抛出异常）。可以通过字节的SHA1的哈希确认每片。

块是比片小的单元。片在传说的过程中可能太大因此传输的是更小的块。每块的大小不固定，因此我们的客户端可能传输不同打下的块给其他人。使用不同大小的块这点无关紧要因为每块由片的index，byte偏移量和长度确定。块只有在每片被验证的情况下请求或者发送，显然只有所有的块得到验证之后片才能得到验证。

我们增加一些变量和方法来保持追踪片和块在torrent中的大小和过程

```c#
public int BlockSize { get; private set; }
public int PieceSize { get; private set; }
public long TotalSize { get { return Files.Sum(x => x.Size); } }

public string FormattedPieceSize { get { return BytesToString(PieceSize); } }
public string FormattedTotalSize { get { return BytesToString(TotalSize); } }

public int PieceCount { get { return PieceHashes.Length; } }

public byte[][] PieceHashes { get; private set; }
public bool[] IsPieceVerified { get; private set; }
public bool[][] IsBlockAcquired { get; private set; }

public string VerifiedPiecesString { get { return String.Join("", IsPieceVerified.Select(x => x ? 1 : 0)); } }
public int VerifiedPieceCount { get { return IsPieceVerified.Count(x => x); } }
public double VerifiedRatio { get { return VerifiedPieceCount / (double)PieceCount; } }
public bool IsCompleted { get { return VerifiedPieceCount == PieceCount; } }
public bool IsStarted { get { return VerifiedPieceCount > 0; } }

public long Uploaded { get; set; } = 0;
public long Downloaded { get { return PieceSize * VerifiedPieceCount; } } // !! incorrect
public long Left { get { return TotalSize - Downloaded; } }

public int GetPieceSize(int piece)
{            
    if (piece == PieceCount - 1)
    { 
        int remainder = Convert.ToInt32(TotalSize % PieceSize);
        if (remainder != 0)
            return remainder;
    }

    return PieceSize;
}

public int GetBlockSize(int piece, int block)
{
    if (block == GetBlockCount(piece) - 1)
    {
        int remainder = Convert.ToInt32(GetPieceSize(piece) % BlockSize);
        if (remainder != 0)
            return remainder;
    }

    return BlockSize;
}

public int GetBlockCount(int piece)
{
    return Convert.ToInt32(Math.Ceiling(GetPieceSize(piece) / (double)BlockSize));
}
```

### 配置

Torrent类的构造函数需要种子文件信息部分的所有数据，它设置跟踪器，加载或者创建单个哈希块，验证下载进度

还有一个PeerListUpdated事件，每当跟踪器接收到更新的peer列表时，它就会被触发。

```C#
![files](D:\myDocuments\pics\files.png)public event EventHandler<List<IPEndPoint>> PeerListUpdated;

private object[] fileWriteLocks;
private static SHA1 sha1 = SHA1.Create();
  
public Torrent(string name, string location, List<FileItem> files, List<string> trackers, int pieceSize, byte[] pieceHashes = null, int blockSize = 16384, bool? isPrivate = false )
{       
    Name = name;
    DownloadDirectory = location;
    Files = files;
    fileWriteLocks = new object[Files.Count];
    for (int i = 0; i < this.Files.Count; i++)
        fileWriteLocks[i] = new object();   

    if (trackers != null)
    {
        foreach (string url in trackers)
        {
            Tracker tracker = new Tracker(url);
            Trackers.Add(tracker);
            tracker.PeerListUpdated += HandlePeerListUpdated;
        }
    }

    PieceSize = pieceSize;
    BlockSize = blockSize;
    IsPrivate = isPrivate;

    int count = Convert.ToInt32(Math.Ceiling(TotalSize / Convert.ToDouble(PieceSize)));

    PieceHashes = new byte[count][];
    IsPieceVerified = new bool[count];
    IsBlockAcquired = new bool[count][];

    for (int i = 0; i < PieceCount; i++)
        IsBlockAcquired[i] = new bool[GetBlockCount(i)];            

    if (pieceHashes == null)
    {
        // this is a new torrent so we have to create the hashes from the files                 
        for (int i = 0; i < PieceCount; i++)
            PieceHashes[i] = GetHash(i);
    }
    else
    {
        for (int i = 0; i < PieceCount; i++)
        {
            PieceHashes[i] = new byte[20];
            Buffer.BlockCopy(pieceHashes, i * 20, PieceHashes[i], 0, 20);
        }
    }

    object info = TorrentInfoToBEncodingObject(this);
    byte[] bytes =  BEncoding.Encode(info);
    Infohash = SHA1.Create().ComputeHash(bytes);

    for (int i = 0; i < PieceCount; i++)
        Verify(i);
}
```

### 读&写

根据下面的表格可以看到，片和块不在乎一个文件何时结束下一个文件还是开始。单个片中可以包含任意数量的文件。

![img](https://media.seanjoflynn.com/images/research/bittorrent/files.png)

我们的Read()和Write()方法只需要开始位置和字节长度。方法都很相似都是选择一个片然后计算出开始和结束的位置，然后循环读取或者写入。Read()方法加载文件的字节到buffer里面然后返回它。读方法将给予的byte[]分块然后将他们写到每个文件正确的位置。我们也加入了lock来防止同时写入一个文件。

```C#
public byte[] Read(long start, int length)
{
    long end = start + length;
    byte[] buffer = new byte[length];

    for (int i=0; i<Files.Count; i++)
    {                
        if ((start < Files[i].Offset && end < Files[i].Offset) ||
            (start > Files[i].Offset + Files[i].Size && end > Files[i].Offset + Files[i].Size))
            continue;

        string filePath = DownloadDirectory + Path.DirectorySeparatorChar + FileDirectory + Files[i].Path;

        if (!File.Exists(filePath))
            return null;

        long fstart = Math.Max(0, start - Files[i].Offset);
        long fend = Math.Min(end - Files[i].Offset, Files[i].Size);
        int flength = Convert.ToInt32(fend - fstart);
        int bstart = Math.Max(0, Convert.ToInt32(Files[i].Offset - start));

        using (Stream stream = new FileStream(filePath, FileMode.Open, FileAccess.Read, FileShare.ReadWrite))
        {                    
            stream.Seek(fstart, SeekOrigin.Begin);
            stream.Read(buffer, bstart, flength);
        }
    }

    return buffer;
}

public void Write(long start, byte[] bytes)
{
    long end = start + bytes.Length;

    for (int i = 0; i < Files.Count; i++)
    {                
        if ((start < Files[i].Offset && end < Files[i].Offset) ||
            (start > Files[i].Offset + Files[i].Size && end > Files[i].Offset + Files[i].Size))
            continue;

        string filePath = DownloadDirectory + Path.DirectorySeparatorChar + FileDirectory + Files[i].Path;

        string dir = Path.GetDirectoryName(filePath);
        if (!Directory.Exists(dir))
            Directory.CreateDirectory(dir);

        lock (fileWriteLocks[i])
        {
            using (Stream stream = new FileStream(filePath, FileMode.OpenOrCreate, FileAccess.ReadWrite))
            {
                long fstart = Math.Max(0, start - Files[i].Offset);
                long fend = Math.Min(end - Files[i].Offset, Files[i].Size);
                int flength = Convert.ToInt32(fend - fstart);
                int bstart = Math.Max(0, Convert.ToInt32(Files[i].Offset - start));

                stream.Seek(fstart, SeekOrigin.Begin);
                stream.Write(bytes, bstart, flength);
            }
        }
    }
}
```

下面是一写读写的帮助函数

```c#
public byte[] ReadPiece(int piece)
{
    return Read(piece * PieceSize, GetPieceSize(piece));
}

public byte[] ReadBlock(int piece, int offset, int length)
{
    return Read(piece * PieceSize + offset, length);
}

public void WriteBlock(int piece, int block, byte[] bytes)
{            
    Write(piece * PieceSize + block * BlockSize, bytes);
    IsBlockAcquired[piece][block] = true;
    Verify(piece);
}
```

每一片的验证都是间接的，一个很重要需要注意的事情就是如果我们获取了所有的块但是验证失败了，就要将这些块重置然后重更新获取他们

```C#
public event EventHandler<int> PieceVerified;
  
public void Verify(int piece)
{
    byte[] hash = GetHash(piece);

    bool isVerified = (hash != null && hash.SequenceEqual(PieceHashes[piece]));

    if (isVerified)
    {                
        IsPieceVerified[piece] = true;

        for (int j = 0; j < IsBlockAcquired[piece].Length; j++)
            IsBlockAcquired[piece][j] = true;

        var handler = PieceVerified;
        if (handler != null)
            handler(this, piece);

        return;
    }

    IsPieceVerified[piece] = false;

    // reload the entire piece
    if (IsBlockAcquired[piece].All(x => x))
    {
        for (int j = 0; j < IsBlockAcquired[piece].Length; j++)
            IsBlockAcquired[piece][j] = false;
    }
}

public byte[] GetHash(int piece)
{
    byte[] data = ReadPiece(piece);

    if (data == null)
        return null;            

    return sha1.ComputeHash(data);
}
```

### 导入&导出

加载和保存种子文件的方式很简单

```C#
public static Torrent LoadFromFile(string filePath, string downloadPath)
{
    object obj = BEncoding.DecodeFile(filePath);
    string name = Path.GetFileNameWithoutExtension(filePath);

    return BEncodingObjectToTorrent(obj, name, downloadPath);
}

public static void SaveToFile(Torrent torrent)
{
    object obj = TorrentToBEncodingObject(torrent);

    BEncoding.EncodeToFile(obj, torrent.Name + ".torrent");
}
```

将种子文件和BEncoding对象转换的工作是最为繁琐的。将信息部分编码的工作在TorrentInfoToBEncodingObject()方法中被拆分了这样我们就可以利用它生成infohashes

```c#
public static long DateTimeToUnixTimestamp( DateTime time )
{
    return Convert.ToInt64((DateTime.UtcNow.Subtract(new DateTime(1970, 1, 1))).TotalSeconds);
}

private static object TorrentToBEncodingObject(Torrent torrent)
{
    Dictionary<string,object> dict = new Dictionary<string, object>();

    if( torrent.Trackers.Count == 1 )
        dict["announce"] = Encoding.UTF8.GetBytes(torrent.Trackers[0].Address);
    else
        dict["announce"] = torrent.Trackers.Select(x => (object)Encoding.UTF8.GetBytes(x.Address)).ToList();
    dict["comment"] = Encoding.UTF8.GetBytes(torrent.Comment);
    dict["created by"] = Encoding.UTF8.GetBytes(torrent.CreatedBy);
    dict["creation date"] = DateTimeToUnixTimestamp(torrent.CreationDate);
    dict["encoding"] = Encoding.UTF8.GetBytes(Encoding.UTF8.WebName.ToUpper());
    dict["info"] = TorrentInfoToBEncodingObject(torrent);

    return dict;
}

private static object TorrentInfoToBEncodingObject(Torrent torrent)
{
    Dictionary<string,object> dict = new Dictionary<string, object>();

    dict["piece length"] = (long)torrent.PieceSize;
    byte[] pieces = new byte[20 * torrent.PieceCount];
    for (int i = 0; i < torrent.PieceCount; i++)
        Buffer.BlockCopy(torrent.PieceHashes[i], 0, pieces, i * 20, 20);
    dict["pieces"] = pieces;

    if (torrent.IsPrivate.HasValue)
        dict["private"] = torrent.IsPrivate.Value ? 1L : 0L;

    if (torrent.Files.Count == 1)
    {                
        dict["name"] = Encoding.UTF8.GetBytes(torrent.Files[0].Path);
        dict["length"] = torrent.Files[0].Size;
    }
    else
    {
        List<object> files = new List<object>();

        foreach (var f in torrent.Files)
        {
            Dictionary<string,object> fileDict = new Dictionary<string, object>();
            fileDict["path"] = f.Path.Split(Path.DirectorySeparatorChar).Select(x => (object)Encoding.UTF8.GetBytes(x)).ToList();
            fileDict["length"] = f.Size;
            files.Add(fileDict);
        }

        dict["files"] = files;
        dict["name"] = Encoding.UTF8.GetBytes(torrent.FileDirectory.Substring(0, torrent.FileDirectory.Length - 1));
    }

    return dict;
}
```

将BEncoding对象和种子文件转换

```c#
public static string DecodeUTF8String( object obj )
{
    byte[] bytes = obj as byte[];

    if (bytes == null)
        throw new Exception("unable to decode utf-8 string, object is not a byte array");

    return Encoding.UTF8.GetString(bytes);
}

public static DateTime UnixTimeStampToDateTime( double unixTimeStamp )
{
    // Unix timestamp is seconds past epoch
    System.DateTime dtDateTime = new DateTime(1970,1,1,0,0,0,0,System.DateTimeKind.Utc);
    dtDateTime = dtDateTime.AddSeconds( unixTimeStamp ).ToLocalTime();
    return dtDateTime;
}

private static Torrent BEncodingObjectToTorrent(object bencoding, string name, string downloadPath)
{
    Dictionary<string,object> obj = (Dictionary<string,object>)bencoding;

    if (obj == null)
        throw new Exception("not a torrent file");
    
    // !! handle list
    List<string> trackers = new List<string>();
    if (obj.ContainsKey("announce"))                
        trackers.Add(DecodeUTF8String(obj["announce"]));            

    if (!obj.ContainsKey("info"))
        throw new Exception("Missing info section");

    Dictionary<string,object> info = (Dictionary<string,object>)obj["info"];

    if (info == null)
        throw new Exception("error");

    List<FileItem> files = new List<FileItem>();

    if (info.ContainsKey("name") && info.ContainsKey("length"))
    {
        files.Add(new FileItem() {
            Path = DecodeUTF8String(info["name"]),
            Size = (long)info["length"]
        });
    }
    else if (info.ContainsKey("files"))
    {
        long running = 0;

        foreach (object item in (List<object>)info["files"])
        {
            var dict = item as Dictionary<string,object>;

            if (dict == null || !dict.ContainsKey("path") || !dict.ContainsKey("length") )
                throw new Exception("error: incorrect file specification");

            string path = String.Join(Path.DirectorySeparatorChar.ToString(), ((List<object>)dict["path"]).Select(x => DecodeUTF8String(x)));

            long size = (long)dict["length"];

            files.Add(new FileItem() {
                Path = path,
                Size = size,
                Offset = running
            });

            running += size;
        }
    }
    else
    {
        throw new Exception("error: no files specified in torrent");
    }
        
    if (!info.ContainsKey("piece length"))
        throw new Exception("error");
    int pieceSize = Convert.ToInt32(info["piece length"]);

    if (!info.ContainsKey("pieces"))
        throw new Exception("error");            
    byte[] pieceHashes = (byte[])info["pieces"];

    bool? isPrivate = null;
    if (info.ContainsKey("private"))
        isPrivate = ((long)info["private"]) == 1L;            
    
    Torrent torrent = new Torrent(name, downloadPath, files, trackers, pieceSize, pieceHashes, 16384, isPrivate );

    if (obj.ContainsKey("comment"))
        torrent.Comment = DecodeUTF8String(obj["comment"]);

    if (obj.ContainsKey("created by"))
        torrent.CreatedBy = DecodeUTF8String(obj["created by"]);

    if (obj.ContainsKey("creation date"))
        torrent.CreationDate = UnixTimeStampToDateTime(Convert.ToDouble(obj["creation date"]));

    if (obj.ContainsKey("encoding"))
        torrent.Encoding = Encoding.GetEncoding(DecodeUTF8String(obj["encoding"]));
    
    return torrent;
}
```

### 创建

如果我们想要创建我们自己的种子文件，我们可以使用Create()方法，可以传入单个文件路径或者目录

```c#
public static Torrent Create(string path, List<string> trackers = null, int pieceSize = 32768, string comment = "")
{
    string name = "";
    List<FileItem> files = new List<FileItem>();

    if (File.Exists(path))
    {
        name = Path.GetFileName(path);

        long size = new FileInfo(path).Length;
        files.Add(new FileItem()
            {
                Path = Path.GetFileName(path),
                Size = size
            });
    }
    else
    {
        name = path;
        string directory = path + Path.DirectorySeparatorChar;

        long running = 0;
        foreach (string file in Directory.EnumerateFiles(path, "*.*", SearchOption.AllDirectories))
        {
            string f = file.Substring(directory.Length);

            if (f.StartsWith("."))
                continue;

            long size = new FileInfo(file).Length;

            files.Add(new FileItem()
                {
                    Path = f,
                    Size = size,
                    Offset = running
                });
            
            running += size;
        }
    }

    Torrent torrent = new Torrent(name, "", files, trackers, pieceSize);
    torrent.Comment = comment;
    torrent.CreatedBy = "TestClient";
    torrent.CreationDate = DateTime.Now;
    torrent.Encoding = Encoding.UTF8;

    return torrent;
}
```

## 追踪器

一旦我们已经准备好了所有的种子信息，我们应该如何寻找对象去连接？我们连接到追踪器的原因有两个，一个是他可以提供一个可以立刻尝试连接的追踪器列表。其次他会把我们加入对象列表中这样之后的新对象可以获得我们的ip地址和相应的端口号。我们要也可以获取当前的文件进度告诉他，一边可以追踪种子和预下载者的数量

### 宣告

跟踪器的最基本版本就是具有单个节点的HTTP服务器，我们本地运行的opentracker使用http://localhost:6969/announce端点，我们需要在HTTP GET请求中加一些参数

- infohash：这是我们种子的哈希，任何影响url的原始字节都需要转义，由UrlSafeStringInfohash属性提供
- peer_id：一个20比特的字符串来验证。大部分客户端使用少量字符来验证程序和版本，随后跟着一些随机字符。我们打算使用随机的数字组成的字符串
- port：监听传入连接的端口
- uploaded：已经上传的的字节数
- downloaded：已经下载的字节数
- left：还剩余需要下载的字节数
- event：当前客户端的状态，started、paused 、stopped。这样追踪器就知道是否需要把我们从对象中加入或者移除
- compact：0或1代表返回compact对象列表，opentracker似乎只能在compact模式下运作

我们可以使用curl来测试request在我们构建之前

```shell
$ curl -v "http://192.168.1.74:6969/announce?info_hash=%3E%09%D0%1CHHCy%CF%27%F23%24%E1%7B%BDijbD&peer_id=76433642664923430920&port=56723&uploaded=0&downloaded=0&left=0&event=started&compact=1"
*   Trying 192.168.1.74...
* Connected to 192.168.1.74 (192.168.1.74) port 6969 (#0)
> GET /announce?info_hash=%3E%09%D0%1CHHCy%CF%27%F23%24%E1%7B%BDijbD&peer_id=76433642664923430920&port=56723&uploaded=0&downloaded=0&left=0&event=started&compact=1 HTTP/1.1
> Host: 192.168.1.74:6969
> User-Agent: curl/7.43.0
> Accept: */*
> 
< HTTP/1.1 200 OK
< Content-Type: text/plain
< Content-Length: 111
< 
* Connection #0 to host 192.168.1.74 left intact
d8:completei2e10:downloadedi0e10:incompletei1e8:intervali1769e12:min intervali884e5:peers18:??J??Jݓ??J??e
```

结果是BEncoded 对象，将其格式化

```shell
d
  8:complete        i2e
  10:downloaded     i0e
  10:incomplete     i1e
  8:interval        i1769e
  12:min interval   i884e
  5:peers           18:??J??Jݓ??J??
e
```

一个个看reponse

- complete：拥有完整文件的对象数量
- downloaded：没有找到相关资料
- incomplete：没有完整文件的对象数量（预下载者）
- interval：客户端从追踪器请求更新对象列表的频率
- min interval：客户端从追踪器请求更新对象列表的最小频率
- peers：在紧凑模式下，是一个byte[]。每6个字节就是一个对象-前四个数字代表IPV4的地址，最后两个代表端口号

让我们在自己的代码中重现这些功能，首先为事件类型创建一个简单的枚举类

```c#
public enum TrackerEvent
{
    Started,
    Paused,
    Stopped
}
```

我们重新看Tracker类并且加入announcing的逻辑。我们的Update()方法创造需要的url。我增加了一个检查来防止过于频繁的检查新的对象。我们还需要一个方法来重置时钟

```c#
public DateTime LastPeerRequest { get; private set; } = DateTime.MinValue;
public TimeSpan PeerRequestInterval { get; private set; } = TimeSpan.FromMinutes(30);

public void Update(Torrent torrent, TrackerEvent ev, string id, int port)
{
    // wait until after request interval has elapsed before asking for new peers
    if (ev == TrackerEvent.Started && DateTime.UtcNow < LastPeerRequest.Add(PeerRequestInterval))
        return;

    LastPeerRequest = DateTime.UtcNow;

    string url = String.Format("{0}?info_hash={1}&peer_id={2}&port={3}&uploaded={4}&downloaded={5}&left={6}&event={7}&compact=1", 
                     Address, torrent.UrlSafeStringInfohash,
                     id, port,
                     torrent.Uploaded, torrent.Downloaded, torrent.Left, 
                     Enum.GetName(typeof(TrackerEvent), ev).ToLower());
    
    Request(url);
}

public void ResetLastRequest()
{
    LastPeerRequest = DateTime.MinValue;
}
```

Request()方法创建真正的HTTP 请求。HttpWebResponse.BeginGetResponse是异步的因此不会阻塞线程。我们可以简单指定一个回调函数(HandleResponse)当追踪器获得回复的时候获取值。我们读取返回的字节，并用BEncoding.Decode()处理。最后，我们解析时间间隔和对象列表来触发PeerListUpdated事件

```c#
private void Request( string url )
{
    httpWebRequest = (HttpWebRequest)HttpWebRequest.Create(url);
    httpWebRequest.BeginGetResponse(HandleResponse, null);
}

private void HandleResponse(IAsyncResult result)
{
    byte[] data;

    using (HttpWebResponse response = (HttpWebResponse)httpWebRequest.EndGetResponse(result))
    {
        if (response.StatusCode != HttpStatusCode.OK)
        {
            Console.WriteLine("error reaching tracker " + this + ": " + response.StatusCode + " " + response.StatusDescription);
            return;
        }
    
        using (Stream stream = response.GetResponseStream())
        {
            data = new byte[response.ContentLength];
            stream.Read(data, 0, Convert.ToInt32(response.ContentLength));
        }
    }

    Dictionary<string,object> info = BEncoding.Decode(data) as Dictionary<string,object>;

    if (info == null)
    {
        Console.WriteLine("unable to decode tracker announce response");
        return;
    }

    PeerRequestInterval = TimeSpan.FromSeconds((long)info["interval"]);
    byte[] peerInfo = (byte[])info["peers"];
        
    List<IPEndPoint> peers = new List<IPEndPoint>();
    for (int i = 0; i < peerInfo.Length/6; i++)
    {
        int offset = i * 6;
        string address = peerInfo[offset] + "." + peerInfo[offset+1] + "." + peerInfo[offset+2] + "." + peerInfo[offset+3];
        int port = EndianBitConverter.Big.ToChar(peerInfo, offset + 4);

        peers.Add(new IPEndPoint(IPAddress.Parse(address), port));
    }

    var handler = PeerListUpdated;
    if (handler != null)
        handler(this, peers);
}
```

这些就是Tracker类中的内容，我们将会继续在Torrent类中更新其中所有的追踪器

```c#
public void UpdateTrackers(TrackerEvent ev, string id, int port)
{
    foreach (var tracker in Trackers)
        tracker.Update(this, ev, id, port);
}

public void ResetTrackersLastUpdated()
{}
```

## 对象

对象之间直接通信。他们打开TCP连接来允许同时收发消息

### 结构

这里面有很多内容，但拆分开来之后不算太糟。我们有一些事件当对象断开连接，他的状态改变或者有数据到达。我们存储一些TCP网络变量来处理从对象那边的字节数据。我们还用一些变量存储对象的状态和进程。我们还追踪我们发出的等待响应的数据请求。最后，我们用一些变量来追踪有多少数据在我们之间转换完成。

```c#
using System;
using System.Collections;
using System.Collections.Concurrent;
using System.Collections.Generic;
using System.Net;
using System.Net.Sockets;
using System.Linq;
using System.Text;
using System.IO;
using MiscUtil.Conversion;

namespace BitTorrent
{
    public class Peer
    {
        public event EventHandler Disconnected;
        public event EventHandler StateChanged;
        public event EventHandler<DataRequest> BlockRequested;
        public event EventHandler<DataRequest> BlockCancelled;
        public event EventHandler<DataPackage> BlockReceived;

        public string LocalId { get; set; }
        public string Id { get; set; }

        public Torrent Torrent { get; private set; }

        public IPEndPoint IPEndPoint { get; private set; }
        public string Key { get { return IPEndPoint.ToString(); } }

        private TcpClient TcpClient { get; set; }
        private NetworkStream stream { get; set; }
        private const int bufferSize = 256;
        private byte[] streamBuffer = new byte[bufferSize];
        private List<byte> data = new List<byte>();

        public bool[] IsPieceDownloaded = new bool[0];
        public string PiecesDownloaded { get { return String.Join("", IsPieceDownloaded.Select(x => Convert.ToInt32(x))); } }
        public int PiecesRequiredAvailable { get { return IsPieceDownloaded.Select((x, i) => x && !Torrent.IsPieceVerified[i]).Count(x => x); } }
        public int PiecesDownloadedCount { get { return IsPieceDownloaded.Count(x => x); } }
        public bool IsCompleted { get { return PiecesDownloadedCount == Torrent.PieceCount; } }

        public bool IsDisconnected;

        public bool IsHandshakeSent;
        public bool IsPositionSent;
        public bool IsChokeSent = true;
        public bool IsInterestedSent = false;

        public bool IsHandshakeReceived;
        public bool IsChokeReceived = true;
        public bool IsInterestedReceived = false;

        public bool[][] IsBlockRequested = new bool[0][];
        public int BlocksRequested { get { return IsBlockRequested.Sum(x => x.Count(y => y)); } }

        public DateTime LastActive;
        public DateTime LastKeepAlive = DateTime.MinValue;

        public long Uploaded;
        public long Downloaded;
    }
}
```

一个对象可以用两种方式创建，我们可以打开连接（这样我们可以指定一个IPEndPoint去连接）或者他们可以打开连接（这样我们就可以接受TcpCLient）

```c#
public Peer(Torrent torrent, string localId, TcpClient client) : this(torrent, localId)
{            
    TcpClient = client;
    IPEndPoint = (IPEndPoint)client.Client.RemoteEndPoint;
}

public Peer(Torrent torrent, string localId, IPEndPoint endPoint): this(torrent, localId)
{
    IPEndPoint = endPoint;
}

private Peer(Torrent torrent, string localId)
{
    LocalId = localId;
    Torrent = torrent;

    LastActive = DateTime.UtcNow;
    IsPieceDownloaded = new bool[Torrent.PieceCount];
    IsBlockRequested = new bool[Torrent.PieceCount][];
    for (int i = 0; i < Torrent.PieceCount; i++)
        IsBlockRequested[i] = new bool[Torrent.GetBlockCount(i)];
}
```

## 协议

对象之间的协议很简单

### 握手

初始时双方都需要发一个握手请求，这制定了他们可以使用相同的扩展协议，并确认他们使用的是相同的种子

### 进度

在握手之后，他们必须立刻确认对方下载种子的进度。之后进度的任何改变都必须要立刻通信

### 状态

所有对象一开始not interested和choked。如果一个对象想要请求数据，他通知一个对象他interested。如果那个对象愿意回复信息请求，他会通知那个对象他unchocked。对象使用这些状态为了限制传播者和接收者的数量，以防拥塞和管理带宽。

### 日期

一旦一个对象unchocked，他可以开始请求数据块。其他对象将会回复这些请求。一些对象可能从不同的对象中请求同一块数据因此如果之前已经获得过可以根据日期来取消请求。

## 连接

一旦我们的对象安装好，我们就开始异步的获取即将到来的数据，我们也可以立刻发生我们的握手（如果我们收到了他们的握手信息，还会发送位置信息）

```c#
public void Connect()
{
    if (TcpClient == null)
    {
        TcpClient = new TcpClient();
        try
        {
            TcpClient.Connect(IPEndPoint);
        }
        catch (Exception e)
        {
            Disconnect();
            return;
        }
    }

    Log.WriteLine(this, "connected");

    stream = TcpClient.GetStream();
    stream.BeginRead(streamBuffer, 0, Peer.bufferSize, new AsyncCallback(HandleRead), null);

    SendHandshake();
    if (IsHandshakeReceived)
        SendBitfield(Torrent.IsPieceVerified);
}
```

除了关闭TCP连接之外，没有协议可以断开与对象的连接，我们还会触发Disconnected事件

```c#
public void Disconnect()
{
    if (!IsDisconnected)
    {
        IsDisconnected = true;
        Log.WriteLine(this, "disconnected, down " + Downloaded + ", up " + Uploaded);
    }

    if (TcpClient != null)
        TcpClient.Close();

    if (Disconnected != null)
        Disconnected(this, new EventArgs());
}
```

为了发送字节，我们简单的将其写入网络流，没有办法通知一个TCP连接是关闭还是开放，因此我们将其放入try...catch之中防止他关闭。

```c#
private void SendBytes(byte[] bytes)
{
    try
    {
        stream.Write(bytes, 0, bytes.Length);
    }
    catch(Exception e)
    {
        Disconnect();
    }
}
```

当我们从流中读取数据的时候，我们把到来的字节放在一个列表中。一旦我们有了足够多的字节，我们确认这些信息的长度，并一直等待，直到它被接收。一旦接收到一个完整的信息，我们对他解码和处理。如果一次读取中含有多个信息，我们就循环处理他们直到结束。

```c#
private void HandleRead( IAsyncResult ar )
{            
    int bytes = 0;
    try
    {
        bytes = stream.EndRead(ar);
    }
    catch (Exception e)
    {
        Disconnect();
        return;
    }
       
    data.AddRange(streamBuffer.Take(bytes));

    int messageLength = GetMessageLength(data);
    while (data.Count >= messageLength)
    {
        HandleMessage(data.Take(messageLength).ToArray());
        data = data.Skip(messageLength).ToList();

        messageLength = GetMessageLength(data);
    }

    try
    {
        stream.BeginRead(streamBuffer, 0, Peer.bufferSize, new AsyncCallback(HandleRead), null);
    }
    catch (Exception e)
    {
        Disconnect();
    }
}

private int GetMessageLength(List<byte> data)
{
    if (!IsHandshakeReceived)
        return 68;

    if (data.Count < 4)
        return int.MaxValue;

    return EndianBitConverter.Big.ToInt32(data.ToArray(), 0) + 4;
}
```

### 消息种类

有10中消息类型有一个字节来表示他们，其他两种被认为是显而易见的。消息类型被一个字节定义。我们准备定义它为int枚举这样我们就可以使用负值标识是否是其他两种类型。我不想将其保持为其保留字节，而是为为生命的类型可能使用的最高值（255及一下），因为这些只可能在未来的规范中为新消息类型定义。

```c#
public enum MessageType : int
{
    Unknown = -3,
    Handshake = -2,
    KeepAlive = -1,
    Choke = 0,
    Unchoke = 1,
    Interested = 2,
    NotInterested = 3,
    Have = 4,
    Bitfield = 5,
    Request = 6,
    Piece = 7,
    Cancel = 8,
    Port = 9,
}
```

### 编码&解码

#### 握手

从一个新的对象那边获得的第一个消息一定要是一个握手消息，它包含这个对象支持的特性，客户端的id和确认种子文件的infohash、

注意到不像其他信息，握手信息的长度被定义为单个byte而不是int（4个字节），并且总是设定为19，即使握手消息的长度是68个字节

![img](https://media.seanjoflynn.com/images/research/bittorrent/handshake.png)

```c#
public static bool DecodeHandshake(byte[] bytes, out byte[] hash, out string id)
{
    hash = new byte[20];
    id = "";

    if (bytes.Length != 68 || bytes[0] != 19)
    {
        Log.WriteLine("invalid handshake, must be of length 68 and first byte must equal 19");
        return false;
    }

    if (Encoding.UTF8.GetString(bytes.Skip(1).Take(19).ToArray()) != "BitTorrent protocol")
    {
        Log.WriteLine("invalid handshake, protocol must equal \"BitTorrent protocol\"");
        return false;
    }

    // flags
    //byte[] flags = bytes.Skip(20).Take(8).ToArray();

    hash = bytes.Skip(28).Take(20).ToArray();

    id = Encoding.UTF8.GetString(bytes.Skip(48).Take(20).ToArray());

    return true;
}

public static byte[] EncodeHandshake(byte[] hash, string id)
{
    byte[] message = new byte[68];
    message[0] = 19;
    Buffer.BlockCopy(Encoding.UTF8.GetBytes("BitTorrent protocol"), 0, message, 1, 19);
    Buffer.BlockCopy(hash,0, message, 28, 20);
    Buffer.BlockCopy(Encoding.UTF8.GetBytes(id), 0, message, 48, 20);

    return message;
}
```

#### 保持通信

保持通信消息是一个没有正文的信息，即其长度为0。

![img](https://media.seanjoflynn.com/images/research/bittorrent/keep-alive.png)

```c#
public static bool DecodeKeepAlive(byte[] bytes)
{            
    if (bytes.Length != 4 || EndianBitConverter.Big.ToInt32(bytes,0) != 0 )
    {
        Log.WriteLine("invalid keep alive");
        return false;
    }
    return true;
}

public static byte[] EncodeKeepAlive()
{
    return EndianBitConverter.Big.GetBytes(0);
}
```

#### 状态

四个状态消息都是1个字节长度，它指示MessageType以及状态的变化。下面的是一个not-interested消息

![img](https://media.seanjoflynn.com/images/research/bittorrent/state.png)

```c#
public static bool DecodeChoke(byte[] bytes)
{            
    return DecodeState(bytes, MessageType.Choke);
}

public static bool DecodeUnchoke(byte[] bytes)
{            
    return DecodeState(bytes, MessageType.Unchoke);
}

public static bool DecodeInterested(byte[] bytes)
{            
    return DecodeState(bytes, MessageType.Interested);
}

public static bool DecodeNotInterested(byte[] bytes)
{            
    return DecodeState(bytes, MessageType.NotInterested);
}

public static bool DecodeState(byte[] bytes, MessageType type)
{            
    if (bytes.Length != 5 || EndianBitConverter.Big.ToInt32(bytes, 0) != 1 || bytes[4] != (byte)type)
    {
        Log.WriteLine("invalid " + Enum.GetName(typeof(MessageType), type));
        return false;
    }
    return true;
}

public static byte[] EncodeChoke() 
{
    return EncodeState(MessageType.Choke);
}

public static byte[] EncodeUnchoke() 
{
    return EncodeState(MessageType.Unchoke);
}

public static byte[] EncodeInterested()
{
    return EncodeState(MessageType.Interested);
}

public static byte[] EncodeNotInterested() 
{
    return EncodeState(MessageType.NotInterested);
}

public static byte[] EncodeState(MessageType type) 
{
    byte[] message = new byte[5];
    Buffer.BlockCopy(EndianBitConverter.Big.GetBytes(1), 0, message, 0, 4);
    message[4] = (byte)type;
    return message;
}
```

#### 进度

have消息指定一片下标用来和对象通信是否下载完成或者验证完成

![img](https://media.seanjoflynn.com/images/research/bittorrent/have.png)

bitfield消息是一个快速和对象进度通信的方式通常是在握手后发生，是一个小追踪器，在类型字节之后，每个字节指定是否对象以及下载了对应片的下标

![img](https://media.seanjoflynn.com/images/research/bittorrent/bitfield.png)

因此在上面的例子中，字节的值是200，如果将其转换为二进制就是1001000。

在这个特殊的例子中，对象1，2，5片下载好之后进行了通信。如果片所代表的数字不能被8整除，bitfield的末尾用0填充。

```c#
public static bool DecodeHave(byte[] bytes, out int index)
{
    index = -1;

    if (bytes.Length != 9 || EndianBitConverter.Big.ToInt32(bytes, 0) != 5)
    {
        Log.WriteLine("invalid have, first byte must equal 0x2");
        return false;
    }

    index = EndianBitConverter.Big.ToInt32(bytes, 5);

    return true;
}

public static bool DecodeBitfield(byte[] bytes, int pieces, out bool[] isPieceDownloaded)
{
    isPieceDownloaded = new bool[pieces];

    int expectedLength = Convert.ToInt32(Math.Ceiling(pieces / 8.0)) + 1;

    if (bytes.Length != expectedLength + 4 || EndianBitConverter.Big.ToInt32(bytes,0) != expectedLength)
    {
        Log.WriteLine("invalid bitfield, first byte must equal " + expectedLength);
        return false;
    }

    BitArray bitfield = new BitArray(bytes.Skip(5).ToArray());

    for (int i = 0; i < pieces; i++)
        isPieceDownloaded[i] = bitfield[bitfield.Length - 1 - i];

    return true;
}

public static byte[] EncodeHave(int index) 
{            
    byte[] message = new byte[9];
    Buffer.BlockCopy(EndianBitConverter.Big.GetBytes(5), 0, message, 0, 4);
    message[4] = (byte)MessageType.Have;
    Buffer.BlockCopy(EndianBitConverter.Big.GetBytes(index), 0, message, 5, 4);

    return message;
}

public static byte[] EncodeBitfield(bool[] isPieceDownloaded) 
{
    int numPieces = isPieceDownloaded.Length;
    int numBytes = Convert.ToInt32(Math.Ceiling(numPieces / 8.0));
    int numBits = numBytes * 8;

    int length = numBytes + 1;

    byte[] message = new byte[length + 4];
    Buffer.BlockCopy(EndianBitConverter.Big.GetBytes(length), 0, message, 0, 4);
    message[4] = (byte)MessageType.Bitfield;

    bool[] downloaded = new bool[numBits];
    for (int i = 0; i < numPieces; i++)
        downloaded[i] = isPieceDownloaded[i];

    BitArray bitfield = new BitArray(downloaded);
    BitArray reversed = new BitArray(numBits);
    for (int i = 0; i < numBits; i++)
        reversed[i] = bitfield[numBits - i - 1];

    reversed.CopyTo(message, 5);

    return message;
}
```

#### 数据

对象可以请求一块数据。对象需要制定片的下标，字节偏移量和需要返回的字节数

![img](https://media.seanjoflynn.com/images/research/bittorrent/request.png)

除了消息类型之外，取消消息和请求消息一样

![img](https://media.seanjoflynn.com/images/research/bittorrent/cancel.png)

一个对象可以请求一片数据。这个命名有点迷惑应为实际上发送的是数据块而不是片。它指定相同的块下标和偏移量，然后包含原始数据

A peer responds to a request with a *piece* message. The naming is a little confusing as it's actually sending a block and not a piece. It specifies the same piece index and byte offset and then contains the raw data.

```c#
public static bool DecodeRequest(byte[] bytes, out int index, out int begin, out int length)
{
    index = -1;
    begin = -1;
    length = -1;

    if (bytes.Length != 17 || EndianBitConverter.Big.ToInt32(bytes,0) != 13)
    {
        Log.WriteLine("invalid request message, must be of length 17");
        return false;
    }

    index = EndianBitConverter.Big.ToInt32(bytes, 5);
    begin = EndianBitConverter.Big.ToInt32(bytes, 9);
    length = EndianBitConverter.Big.ToInt32(bytes, 13);

    return true;
}

public static bool DecodePiece(byte[] bytes, out int index, out int begin, out byte[] data)
{
    index = -1;
    begin = -1;
    data = new byte[0];

    if (bytes.Length < 13)
    {
        Log.WriteLine("invalid piece message");
        return false;
    }

    int length = EndianBitConverter.Big.ToInt32(bytes, 0) - 9;
    index = EndianBitConverter.Big.ToInt32(bytes, 5);
    begin = EndianBitConverter.Big.ToInt32(bytes, 9);

    data = new byte[length];
    Buffer.BlockCopy(bytes, 13, data, 0, length);

    return true;
}

public static bool DecodeCancel(byte[] bytes, out int index, out int begin, out int length)
{
    index = -1;
    begin = -1;
    length = -1;

    if (bytes.Length != 17 || EndianBitConverter.Big.ToInt32(bytes,0) != 13)
    {
        Log.WriteLine("invalid cancel message, must be of length 17");
        return false;
    }

    index = EndianBitConverter.Big.ToInt32(bytes, 5);
    begin = EndianBitConverter.Big.ToInt32(bytes, 9);
    length = EndianBitConverter.Big.ToInt32(bytes, 13);

    return true;
}
        
public static byte[] EncodeRequest(int index, int begin, int length) 
{
    byte[] message = new byte[17];
    Buffer.BlockCopy(EndianBitConverter.Big.GetBytes(13), 0, message, 0, 4);
    message[4] = (byte)MessageType.Request;
    Buffer.BlockCopy(EndianBitConverter.Big.GetBytes(index), 0, message, 5, 4);
    Buffer.BlockCopy(EndianBitConverter.Big.GetBytes(begin), 0, message, 9, 4);
    Buffer.BlockCopy(EndianBitConverter.Big.GetBytes(length), 0, message, 13, 4);

    return message;
}

public static byte[] EncodePiece(int index, int begin, byte[] data) 
{
    int length = data.Length + 9;

    byte[] message = new byte[length + 4];
    Buffer.BlockCopy(EndianBitConverter.Big.GetBytes(length), 0, message, 0, 4);
    message[4] = (byte)MessageType.Piece;
    Buffer.BlockCopy(EndianBitConverter.Big.GetBytes(index), 0, message, 5, 4);
    Buffer.BlockCopy(EndianBitConverter.Big.GetBytes(begin), 0, message, 9, 4);
    Buffer.BlockCopy(data, 0, message, 13, data.Length);

    return message;
}

public static byte[] EncodeCancel(int index, int begin, int length) 
{
    byte[] message = new byte[17];
    Buffer.BlockCopy(EndianBitConverter.Big.GetBytes(13), 0, message, 0, 4);
    message[4] = (byte)MessageType.Cancel;
    Buffer.BlockCopy(EndianBitConverter.Big.GetBytes(index), 0, message, 5, 4);
    Buffer.BlockCopy(EndianBitConverter.Big.GetBytes(begin), 0, message, 9, 4);
    Buffer.BlockCopy(EndianBitConverter.Big.GetBytes(length), 0, message, 13, 4);

    return message;
}
```

### 发送信息

每个对象都有发送每种类型的方法，通常只是更新它的内部状态和记录通信

```c#
private void SendHandshake()
{
    if (IsHandshakeSent)
        return;

    Log.WriteLine(this, "-> handshake" );
    SendBytes(EncodeHandshake(Torrent.Infohash, LocalId));
    IsHandshakeSent = true;
}

public void SendKeepAlive()
{
    if( LastKeepAlive > DateTime.UtcNow.AddSeconds(-30) )
        return;

    Log.WriteLine(this, "-> keep alive" );
    SendBytes(EncodeKeepAlive());
    LastKeepAlive = DateTime.UtcNow;
}

public void SendChoke() 
{
    if (IsChokeSent)
        return;
    
    Log.WriteLine(this, "-> choke" );
    SendBytes(EncodeChoke());
    IsChokeSent = true;
}

public void SendUnchoke() 
{
    if (!IsChokeSent)
        return;
    
    Log.WriteLine(this, "-> unchoke" );
    SendBytes(EncodeUnchoke());
    IsChokeSent = false;
}

public void SendInterested()
{
    if (IsInterestedSent)
        return;
    
    Log.WriteLine(this, "-> interested");
    SendBytes(EncodeInterested());
    IsInterestedSent = true;
}

public void SendNotInterested() 
{
    if (!IsInterestedSent)
        return;

    Log.WriteLine(this, "-> not interested");
    SendBytes(EncodeNotInterested());
    IsInterestedSent = false;
}

public void SendHave(int index) 
{
    Log.WriteLine(this, "-> have " + index);
    SendBytes(EncodeHave(index));
}

public void SendBitfield(bool[] isPieceDownloaded) 
{
    Log.WriteLine(this, "-> bitfield " + String.Join("", isPieceDownloaded.Select(x => x ? 1 : 0)));
    SendBytes(EncodeBitfield(isPieceDownloaded));
}

public void SendRequest(int index, int begin, int length) 
{
    Log.WriteLine(this, "-> request " + index + ", " + begin + ", " + length);
    SendBytes(EncodeRequest(index, begin, length));
}

public void SendPiece(int index, int begin, byte[] data) 
{
    Log.WriteLine(this, "-> piece " + index + ", " + begin + ", " + data.Length);
    SendBytes(EncodePiece(index, begin, data));
    Uploaded += data.Length;
}

public void SendCancel(int index, int begin, int length) 
{
    Log.WriteLine(this, "-> cancel");
    SendBytes(EncodeCancel(index, begin, length));
}
```

### 获取消息

首先，我们创建一个方法来获取到来的字节数组然后返回它的消息类型。我们检查到来的消息是否是未隐式声明的两种类型之一。握手消息必须是从对象那边获取的第一个消息。第二个是简单为空keep-alive消息（即长度整数头部设置为0）。在整数长度之后的字节，第五个字节，代表消息类型，我们可以将其转换为我们的消息类型枚举。如果我们不知道它是什么类型，将其标记为unknown。

```c#
private MessageType GetMessageType(byte[] bytes)
{
    if (!IsHandshakeReceived)
        return MessageType.Handshake;

    if (bytes.Length == 4 && EndianBitConverter.Big.ToInt32(bytes, 0) == 0)
        return MessageType.KeepAlive;

    if (bytes.Length > 4 && Enum.IsDefined(typeof(MessageType), (int)bytes[4]))
        return (MessageType)bytes[4];

    return MessageType.Unknown;
}
```

下面就是这么做的意义。这个方法获取我们到来的信息，辨识它的类型，将其解码然后传给对应的处理方法。你将会注意到如果消息类型是unknown，我们会简单的忽视它，因为我们如果在此抛出异常，我们的程序就不能继续处理之后的消息类型，即使是那些兼容的。我们在解码函数中使用out参数因为在有些消息中可能包含多种值，因此我们返回bool来标识消息是否被成功解码。如果任何消息解码失败，我们将从对应的对象断开连接

```c#
private void HandleMessage(byte[] bytes)
{
    LastActive = DateTime.UtcNow;

    MessageType type = GetMessageType(bytes);

    if (type == MessageType.Unknown)
    {
        return;   
    }
    else if (type == MessageType.Handshake)
    {
        byte[] hash;
        string id;
        if (DecodeHandshake(bytes, out hash, out id))
        {
            HandleHandshake(hash, id);
            return;
        }
    }
    else if (type == MessageType.KeepAlive && DecodeKeepAlive(bytes))
    {
        HandleKeepAlive();
        return;
    }
    else if (type == MessageType.Choke && DecodeChoke(bytes))
    {
        HandleChoke();
        return;
    }
    else if (type == MessageType.Unchoke && DecodeUnchoke(bytes))
    {
        HandleUnchoke();
        return;
    }
    else if (type == MessageType.Interested && DecodeInterested(bytes))
    {                
        HandleInterested();
        return;
    }
    else if (type == MessageType.NotInterested && DecodeNotInterested(bytes))
    {
        HandleNotInterested();
        return;
    }
    else if (type == MessageType.Have)
    {
        int index;
        if (DecodeHave(bytes, out index))
        {
            HandleHave(index);
            return;
        }                
    }
    else if (type == MessageType.Bitfield)
    {
        bool[] isPieceDownloaded;
        if (DecodeBitfield(bytes, IsPieceDownloaded.Length, out isPieceDownloaded))
        {
            HandleBitfield(isPieceDownloaded);
            return;
        }
    }
    else if (type == MessageType.Request)
    {
        int index;
        int begin;
        int length;
        if (DecodeRequest(bytes, out index, out begin, out length))
        {
            HandleRequest(index, begin, length);
            return;
        }
    }
    else if (type == MessageType.Piece)
    {
        int index;
        int begin;
        byte[] data;
        if (DecodePiece(bytes, out index, out begin, out data))
        {
            HandlePiece(index, begin, data);
            return;
        }
    }
    else if (type == MessageType.Cancel)
    {
        int index;
        int begin;
        int length;
        if (DecodeCancel(bytes, out index, out begin, out length))
        {
            HandleCancel(index, begin, length);
            return;
        }
    }
    else if (type == MessageType.Port)
    {
        Log.WriteLine(this, " <- port: " + String.Join("", bytes.Select(x => x.ToString("x2"))));
        return;
    }

    Log.WriteLine(this, " Unhandled incoming message " + String.Join("", bytes.Select(x => x.ToString("x2"))));
    Disconnect();
}
```

我们处理每种消息类型的方法相当简单。握手消息只需要确认infohash并且设置对象id。keepalive方法什么都不做直到我们在任何消息中更新LastActive变量。忽略port消息。

```c#
private void HandleHandshake(byte[] hash, string id)
{
    Log.WriteLine(this, "<- handshake");

    if (!Torrent.Infohash.SequenceEqual(hash))
    {
        Log.WriteLine(this, "invalid handshake, incorrect torrent hash: expecting=" + Torrent.HexStringInfohash + ", received =" + String.Join("", hash.Select(x => x.ToString("x2"))));
        Disconnect();
        return;
    }

    Id = id;

    IsHandshakeReceived = true;
    SendBitfield(Torrent.IsPieceVerified);
}            

private void HandleKeepAlive() 
{
    Log.WriteLine(this, "<- keep alive");
}

private void HandlePort(int port) 
{
    Log.WriteLine(this, "<- port");
}
```

状态和进度消息类型仅仅更新状态和进度变量然后触发StateChanged事件

```c#
private void HandleChoke() 
{
    Log.WriteLine(this, "<- choke");
    IsChokeReceived = true;

    var handler = StateChanged;
    if (handler != null)
        handler(this, new EventArgs());
}

private void HandleUnchoke() 
{
    Log.WriteLine(this, "<- unchoke");
    IsChokeReceived = false;

    var handler = StateChanged;
    if (handler != null)
        handler(this, new EventArgs());
}

private void HandleInterested() 
{
    Log.WriteLine(this, "<- interested");
    IsInterestedReceived = true;

    var handler = StateChanged;
    if (handler != null)
        handler(this, new EventArgs());
}

private void HandleNotInterested() 
{
    Log.WriteLine(this, "<- not interested");
    IsInterestedReceived = false;

    var handler = StateChanged;
    if (handler != null)
        handler(this, new EventArgs());
}

private void HandleHave(int index)
{
    IsPieceDownloaded[index] = true;
    Log.WriteLine(this, "<- have " + index + " - " + PiecesDownloadedCount + " available (" + PiecesDownloaded + ")");

    var handler = StateChanged;
    if (handler != null)
        handler(this, new EventArgs());
}

private void HandleBitfield(bool[] isPieceDownloaded)
{
    for (int i = 0; i < Torrent.PieceCount; i++)
        IsPieceDownloaded[i] = IsPieceDownloaded[i] || isPieceDownloaded[i];

    Log.WriteLine(this, "<- bitfield " + PiecesDownloadedCount + " available (" + PiecesDownloaded + ")");

    var handler = StateChanged;
    if (handler != null)
        handler(this, new EventArgs());
}
```

我们创建两个简单的类，一个用来追踪我们获得的和需要被处理的，另一个来保持追踪我们即将到来的数据

```c#
public class DataRequest
{
    public Peer Peer;
    public int Piece;
    public int Begin;
    public int Length;
    public bool IsCancelled;
}

public class DataPackage
{
    public Peer Peer;
    public int Piece;
    public int Block;
    public byte[] Data;
}
```

这些信息数据将会触发他们自己代表的事件

```c#
private void HandleRequest(int index, int begin, int length)
{
    Log.WriteLine(this, "<- request " + index + ", " + begin + ", " + length);

    var handler = BlockRequested;
    if (handler != null)
    {
        handler(this, new DataRequest()
            {
                Peer = this,
                Piece = index,
                Begin = begin,
                Length = length
            });
    }
}

private void HandlePiece(int index, int begin, byte[] data) 
{
    Log.WriteLine(this, "<- piece " + index + ", " + begin + ", " + data.Length);
    Downloaded += data.Length;

    var handler = BlockReceived;
    if (handler != null)
    {
        handler(this, new DataPackage()
            {
                Peer = this,
                Piece = index,
                Block = begin / Torrent.BlockSize,
                Data = data
            });
    }
}

private void HandleCancel(int index, int begin, int length) 
{
    Log.WriteLine(this, " <- cancel");

    var handler = BlockCancelled;
    if (handler != null)
    {
        handler(this, new DataRequest()
            {
                Peer = this,
                Piece = index,
                Begin = begin,
                Length = length
            });
    }
}
```

## 客户端

客户端有5个目标

- 读取种子文件
- 从追踪器中请求对象列表，并通知他们进展
- 连接对象并接受对象即将到来的连接，并通知他们进展
- 选择一个对象允许从我们这里获取数据，我们将处理他们请求的任何数据，但限制上传的数据量
- 选择一个对象来获取数据。一旦他们接受了，我们可选择请求数据块，将这些块的请求发出然后获得他们的时候开始处理

让我们从一个简单的client类开始。我们使用ConcurrentDictionary<string,Peer>因为我们有不同的线程在这些列表上运行，我们可能在其他线程上删除或者增加对象,

```c#
using System;
using System.Collections.Concurrent;
using System.Collections.Generic;
using System.Net;
using System.Net.Sockets;
using System.Linq;
using System.Threading;

namespace BitTorrent
{
    public class Client
    {
        public int Port { get; private set; }
        public Torrent Torrent { get; private set; }

        public string Id { get; private set; }

        private Random random = new Random();

        public Client(int port, string torrentPath, string downloadPath)
        {
            // generate random numerical id
            Id = "";
            for (int i = 0; i < 20; i++)
                Id += (random.Next(0, 10));

            Port = port;

            Torrent = Torrent.LoadFromFile(torrentPath, downloadPath);
            Torrent.PieceVerified += HandlePieceVerified;
            Torrent.PeerListUpdated += HandlePeerListUpdated;

            Log.WriteLine(Torrent);
        }
    }
}  

```

### 线程

我们将在客户端中派出4个线程。应用程序中还会运行其他各种线程，大部分是异步网络IO。Start()和Stop()方法将会控制这四个线程，每个线程会控制客户端的不同方面：

- 更新追踪器
- 选择种子和宿主
- 选择请求片和节流下载
- 处理请求和节流上传

```c#
private bool isStopping;
private int isProcessPeers = 0;
private int isProcessUploads = 0;
private int isProcessDownloads = 0;

public void Start()
{
    Log.WriteLine("starting client");

    isStopping = false;

    Torrent.ResetTrackersLastRequest();

    EnablePeerConnections();

    // tracker thread
    new Thread(new ThreadStart(() =>
            {
                while (!isStopping)
                {
                    Torrent.UpdateTrackers(TrackerEvent.Started, Id, Port);
                    Thread.Sleep(10000);
                }
            })).Start();

    // peer thread
    new Thread(new ThreadStart(() =>
            { 
                while (!isStopping)
                {
                    ProcessPeers();
                    Thread.Sleep(1000);
                }
            })).Start();

    // upload thread
    new Thread(new ThreadStart(() =>
            { 
                while (!isStopping)
                {
                    ProcessUploads();
                    Thread.Sleep(1000);
                }
            })).Start();

    // download thread
    new Thread(new ThreadStart(() =>
            { 
                while (!isStopping)
                {
                    ProcessDownloads();
                    Thread.Sleep(1000);
                }
            })).Start();
}

public void Stop()
{
    Log.WriteLine("stopping client");

    isStopping = true;
    DisablePeerConnections();
    Torrent.UpdateTrackers(TrackerEvent.Stopped, Id, Port);
}
```

我们需要处理追踪器更新的到来的对象列表。数显我们有一个静态的帮助属性来给我们提供我们的IP地址-我们不会想要尝试连接自己。当我们接收到IPEndPoint列表，我们简单的为每一个创建一个新的对象，他会尝试连接那个端点。

```c#
public ConcurrentDictionary Peers { get; } = new ConcurrentDictionary();
public ConcurrentDictionary Seeders { get; } = new ConcurrentDictionary();
public ConcurrentDictionary Leechers { get; } = new ConcurrentDictionary();

private static IPAddress LocalIPAddress
{
    get
    {
        var host = Dns.GetHostEntry(Dns.GetHostName());
        foreach (var ip in host.AddressList)
        {
            if (ip.AddressFamily == AddressFamily.InterNetwork)
                return ip;                
        }
        throw new Exception("Local IP Address Not Found!");
    }
}

private void HandlePeerListUpdated(object sender, List endPoints)
{
    IPAddress local = LocalIPAddress;

    foreach(var endPoint in endPoints)
    {
        if (endPoint.Address.Equals(local) && endPoint.Port == Port)
            continue;
        
        AddPeer(new Peer(Torrent, Id, endPoint));
    }

    Log.WriteLine("received peer information from " + (Tracker)sender);
    Log.WriteLine("peer count: " + Peers.Count);
}
```

获得新对象的第二种方式是他们是否与我们联系。我们需要打开一个端口来等待到来的TCP连接，我们用异步的TcpListener.BeginAcceptTcpClient()方法，这样他不会阻塞我们现在进程，我们HandleNewConnection回调方法获取新的TcpClient然后从其中创造一个对象。然后我们开始监听新的连接

```c#
private TcpListener listener;
  
private void EnablePeerConnections()
{
    listener = new TcpListener(new IPEndPoint(IPAddress.Any, Port));
    listener.Start();
    listener.BeginAcceptTcpClient(new AsyncCallback(HandleNewConnection), null);

    Log.WriteLine("started listening for incoming peer connections on port " + Port);
}

private void HandleNewConnection(IAsyncResult ar)
{
    if (listener == null)
        return;

    TcpClient client = listener.EndAcceptTcpClient(ar);
    listener.BeginAcceptTcpClient(new AsyncCallback(HandleNewConnection), null);

    AddPeer(new Peer(Torrent, Id, client));
}
```

DisablePeerConnections()方法简单的停止监听端口并且断开目前所有和对象的连接

```c#
private void DisablePeerConnections()
{
    listener.Stop();
    listener = null;

    foreach (var peer in Peers)
        peer.Value.Disconnect();

    Log.WriteLine("stopped listening for incoming peer connections on port " + Port);
}
```

每当有一个新的对象，我们必须将他的事件连接到我们的处理程序，并将其添加到我们的对象列表中

```c#
private void AddPeer(Peer peer)
{
    peer.BlockRequested += HandleBlockRequested;
    peer.BlockCancelled += HandleBlockCancelled;
    peer.BlockReceived += HandleBlockReceived;
    peer.Disconnected += HandlePeerDisconnected;
    peer.StateChanged += HandlePeerStateChanged;

    peer.Connect();

    if (!Peers.TryAdd(peer.Key, peer))
        peer.Disconnect();
}
```

当一个对象断开连接（由任何一方），取消他的订阅事件。如果我们不这么做，对象会被垃圾回收删除掉

```c#
private void HandlePeerDisconnected(object sender, EventArgs args)
{            
    Peer peer = sender as Peer;

    peer.BlockRequested -= HandleBlockRequested;
    peer.BlockCancelled -= HandleBlockCancelled;
    peer.BlockReceived -= HandleBlockReceived;
    peer.Disconnected -= HandlePeerDisconnected;
    peer.StateChanged -= HandlePeerStateChanged;

    Peer tmp;
    Peers.TryRemove(peer.Key, out tmp);
    Seeders.TryRemove(peer.Key, out tmp);
    Leechers.TryRemove(peer.Key, out tmp);
}
```

当一个对象的状态改变或者我们验证了一个新的片，我们需要再次处理对象列表，在验证片的情况下，我们还必须通知它我们的进展

```c#
private void HandlePeerStateChanged(object sender, EventArgs args)
{
    ProcessPeers();
}

private void HandlePieceVerified (object sender, int index)
{
    ProcessPeers();

    foreach (var peer in Peers)
    {
        if (!peer.Value.IsHandshakeReceived || !peer.Value.IsHandshakeSent)
            continue;

        peer.Value.SendHave(index);
    }
}
```

我创建了一些硬编码的变量作为一些属性

```c#
private static int maxLeechers = 5;
private static int maxSeeders = 5;

private static int maxUploadBytesPerSecond = 16384;
private static int maxDownloadBytesPerSecond = 16384;

private static TimeSpan peerTimeout = TimeSpan.FromSeconds(30);
```

ProcessPeers()方法更新我们与每个对象的状态，然后觉得宿主和种子

- 它会清除所有在一定时间内没有给我们发送任何消息的对象
- 它更新interested/not interested标识决定我们是否结束下载
- 如果我们都结束了，它将断开连接因为已经无事可做
- 如果有需求，他会发送keep alive消息
- 它将不断选择种子直到达到maxSeeders。对象根据我们仍需并且他们所有块的数字块排序。我们之前应该表示哪些是interested。因此他们之间任何一个解除阻塞，我们就会把他添加到种子列表
- 它将不断地选取宿主直到maxLeechers。如果他们interested，我们就解除阻塞。对象的排序对于宿主来说可能是不公平的

下面的方法使用Interlocked.Exchange来防止它在多个线程上运行

```c#
private void ProcessPeers()
{
    if (Interlocked.Exchange(ref isProcessPeers, 1) == 1)
        return;

    foreach (var peer in Peers.OrderByDescending(x => x.Value.PiecesRequiredAvailable))
    {
        if (DateTime.UtcNow > peer.Value.LastActive.Add(peerTimeout))
        {                    
            peer.Value.Disconnect();
            continue;
        }

        if (!peer.Value.IsHandshakeSent || !peer.Value.IsHandshakeReceived)
            continue;

        if (Torrent.IsCompleted)
            peer.Value.SendNotInterested();
        else
            peer.Value.SendInterested();

        if (peer.Value.IsCompleted && Torrent.IsCompleted)
        {
            peer.Value.Disconnect();
            continue;
        }

        peer.Value.SendKeepAlive();

        // let them leech
        if (Torrent.IsStarted && Leechers.Count < maxLeechers)
        {
            if (peer.Value.IsInterestedReceived && peer.Value.IsChokeSent)
                peer.Value.SendUnchoke();                
        }

        // ask to leech
        if (!Torrent.IsCompleted && Seeders.Count <= maxSeeders)
        {
            if(!peer.Value.IsChokeReceived )
                Seeders.TryAdd(peer.Key, peer.Value);
        }
    }

    Interlocked.Exchange(ref isProcessPeers, 0);
}
```

## 节流

我使用了一个很粗糙的Throttle类来防止客户端超过带宽限制。你可以指定时间范围内的最大字节数。添加到列表中的项目会打上时间戳，一旦它们不再出现时间窗口中，就将其从列表中删除。我使用了lock来保证线程安全。是否节流取决于用户。而且，它只表明一旦我们超过了限制（而不是在某件东西导致我们限制之前），我们就会被限制

```c#
using System;
using System.Linq;
using System.Collections.Generic;

namespace BitTorrent
{
    public class Throttle
    {
        public long MaximumSize { get; private set; }
        public TimeSpan MaximumWindow { get; private set; }

        internal struct Item
        {
            public DateTime Time;
            public long Size;
        }

        private object itemLock = new object();
        private List<Item> items = new List<Item>();

        public Throttle(int maxSize, TimeSpan maxWindow)
        {
            MaximumSize = maxSize;
            MaximumWindow = maxWindow;
        }

        public void Add(long size)
        {
            lock (itemLock)
            {
                items.Add(new Item() { Time = DateTime.UtcNow, Size = size });
            }
        }

        public bool IsThrottled
        {
            get
            { 
                lock (itemLock)
                {
                    DateTime cutoff = DateTime.UtcNow.Add(-this.MaximumWindow);
                    items.RemoveAll(x => x.Time < cutoff);
                    return items.Sum(x => x.Size) >= MaximumSize;
                }
            }
        }
    }
}
```

### 上传

我们将即将到来的数据请求放在ConcurrentQueue<DataRequest>。因为我们不能直接从队列中删除一个被取消的项，我们将其标记为取消，这样处理的时候就可以跳过他们

```c#
private ConcurrentQueue<DataRequest> OutgoingBlocks = new ConcurrentQueue<DataRequest>();
  
private void HandleBlockRequested(object sender, DataRequest block)
{
    OutgoingBlocks.Enqueue(block);

    ProcessUploads();
}

private void HandleBlockCancelled(object sender, DataRequest block)
{
    foreach (var item in OutgoingBlocks)
    {
        if (item.Peer != block.Peer || item.Piece != block.Piece || item.Begin != block.Begin || item.Length != block.Length)
            continue;

        item.IsCancelled = true;
    }

    ProcessUploads();
}
```

处理我们的输出队列是一个简单的while循环，将每一项从队列中取出，检测是否被取消。然后我们就会获得那片然后发送他。

```c#
private Throttle uploadThrottle = new Throttle(maxUploadBytesPerSecond, TimeSpan.FromSeconds(1));

private void ProcessUploads()
{
    if (Interlocked.Exchange(ref isProcessUploads, 1) == 1)
        return;

    DataRequest block;
    while (!uploadThrottle.IsThrottled && OutgoingBlocks.TryDequeue(out block))
    {
        if (block.IsCancelled)
            continue;

        if (!Torrent.IsPieceVerified[block.Piece])
            continue;            

        byte[] data = Torrent.ReadBlock(block.Piece, block.Begin, block.Length);
        if (data == null)
            continue;

        block.Peer.SendPiece(block.Piece, block.Begin, data);
        uploadThrottle.Add(block.Length);
        Torrent.Uploaded += block.Length;
    }

    Interlocked.Exchange(ref isProcessUploads, 0);
}
```

### 下载

我们从对象中获得一块数据，然后将它推到ConcurrentQueue<DataPackage>来处理。我们同时也取消同一块但来自其他对象的请求。

```c#
private ConcurrentQueue<DataPackage> IncomingBlocks = new ConcurrentQueue<DataPackage>();
  
private void HandleBlockReceived(object sender, DataPackage args)
{
    IncomingBlocks.Enqueue(args);

    args.Peer.IsBlockRequested[args.Piece][args.Block] = false;

    foreach(var peer in Peers)
    {
        if (!peer.Value.IsBlockRequested[args.Piece][args.Block])
            continue;

        peer.Value.SendCancel(args.Piece, args.Block * Torrent.BlockSize, Torrent.BlockSize);
        peer.Value.IsBlockRequested[args.Piece][args.Block] = false;
    }

    ProcessDownloads();
}
```

ProcessDownloads() 方法比上传的大了不少，首先我们要循环遍历即将到来的队列然后将任何到来的数据写入磁盘，如果我们下载完成，我们就不需要做其他的事情了。

如果没有下载完成，我们需要将我们想要请求的片排名。然后我们将给请求他们的种子源排名。在这个版本，我们限制每次只能从每个客户端请求一次。我们同时也从其他客户端请求一片而不是多个客户端。我们从每个片顺序请求块，我们的请求被限流。

```c#
private Throttle downloadThrottle = new Throttle(maxDownloadBytesPerSecond, TimeSpan.FromSeconds(1));

private void ProcessDownloads()
{
    if (Interlocked.Exchange(ref isProcessDownloads, 1) == 1)
        return;

    DataPackage incomingBlock;
    while (IncomingBlocks.TryDequeue(out incomingBlock))
        Torrent.WriteBlock(incomingBlock.Piece, incomingBlock.Block, incomingBlock.Data);

    if (Torrent.IsCompleted)
    {
        Interlocked.Exchange(ref isProcessDownloads, 0);
        return;
    }

    int[] ranked = GetRankedPieces();

    foreach (var piece in ranked)
    {
        if (Torrent.IsPieceVerified[piece])
            continue;

        foreach (var peer in GetRankedSeeders())
        {
            if (!peer.IsPieceDownloaded[piece])
                continue;

            // just request blocks in order
            for (int block = 0; block < Torrent.GetBlockCount(piece); block++)
            {                        
                if (downloadThrottle.IsThrottled)
                    continue;

                if(Torrent.IsBlockAcquired[piece][block])
                    continue;

                // only request one block from each peer at a time
                if (peer.BlocksRequested > 0)
                    continue;

                // only request from 1 peer at a time
                if (Peers.Count(x => x.Value.IsBlockRequested[piece][block]) > 0)
                    continue;

                int size = Torrent.GetBlockSize(piece, block);
                peer.SendRequest(piece, block * Torrent.BlockSize, size);
                downloadThrottle.Add(size);
                peer.IsBlockRequested[piece][block] = true;
            }
        }
    }

    Interlocked.Exchange(ref isProcessDownloads, 0);
}
```

我们的排名方法很简单，我们简单的给选中的种子源随机排序

```c#
private Peer[] GetRankedSeeders()
{
    return Seeders.Values.OrderBy(x => random.Next(0, 100)).ToArray();
}
```

当决定了下载哪一片的时候，我们结合三个字节的信息来获得每一片的分数。然后我们将给这些片按照分说排序，这三个字节的信息是

- 我们在这片上的进展，就是我们在这片上下载了多少块，我们想要优先完成完整的片段，这样可以验证他们然后将他们作为种子
- 片的稀有度，就是多少对象拥有此片。我们希望优先下载这些稀有的片来防止种子源断开连接
- 随机的值这样的话客户端就不会请求同样的片如果他们的进度相同。

```c#
private int[] GetRankedPieces()
{
    var indexes = Enumerable.Range(0, Torrent.PieceCount).ToArray();
    var scores = indexes.Select(x => GetPieceScore(x)).ToArray();
        
    Array.Sort(scores, indexes);
    Array.Reverse(indexes);

    return indexes;
}

private double GetPieceScore(int piece)
{
    double progress = GetPieceProgress(piece);
    double rarity = GetPieceRarity(piece);

    if( progress == 1.0 )
        progress = 0;

    double rand = random.Next(0,100) / 1000.0;

    return progress + rarity + rand;
}

private double GetPieceProgress(int index)
{
    return Torrent.IsBlockAcquired[index].Average(x => x ? 1.0 : 0.0);
}

private double GetPieceRarity(int index)
{
    if(Peers.Count < 1 )
        return 0.0;

    return Peers.Average(x => x.Value.IsPieceDownloaded[index] ? 0.0 : 1.0);
}
```

