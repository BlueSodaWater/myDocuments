## BEncoding

让我们打开这个之前在记事本中创建的种子文件

```c#
d8:announce33:http://192.168.1.74:6969/announce7:comment17:Comment goes here10:created by25:Transmission/2.92 (14714)13:creation datei1460444420e8:encoding5:UTF-84:infod6:lengthi59616e4:name9:lorem.txt12:piece lengthi32768e6:pieces40:L@fR���3�K*Ez�>_YS��86��"�&�p�<�6�C{�9G7:privatei0eeexxxxxxxxxx d8:announce33:http://192.168.1.74:6969/announce7:comment17:Comment goes here10:created by25:Transmission/2.92 (14714)13:creation datei1460444420e8:encoding5:UTF-84:infod6:lengthi59616e4:name9:lorem.txt12:piece lengthi32768e6:pieces40:L@fR���3�K*Ez�>_YS��86��"�&�p�<�6�C{�9G7:privatei0eeeC

```

看起来很杂乱

## 解码

### 数字

如果知道下一个对象是数字，就遍历数组直到找到代表数字结尾的字母(e)，把这个过程中的bytes记录下来，然后我们把这些bytes先转化为string再转换为long。使用long的原因是因为有些数字代表文件的字节数，可能会大于int的最大值。

### 字符串

对于字符串，我们需要解析两个都独立的部分，第一个部分是标识字节数组长度的数字，第二部分是字节本身。因此首先，就遍历数组直到找到代表数字结尾的字母。在此使用do...while因为需要第一个字符。然后和解码数字过程一样，我们把这些bytes先转化为string再转换为int来得到长度。这个长度代表数组中有多少字节，我们可以遍历数组直到拿到所有字节。

### 链表

对于链表，我们简单的抓取下一个对象直到遇到结尾字符。我们不需要知道链表中的对象类型是什么，只需要将它们装进去。规范没有指定它们的所有项是否都是相同的类型，在我们的引用中，无需检查。

### 字典

字典采用同样的处理方法，唯一的不同支持就是，我们一次取出两个对象（一个key，一个value）然后把他们写入字典中，key必须是合法的UTF-8的字符串。

字典中的项必须按照key中的原始UTF-8字节排序  。这对于我们检查传入字典是否正确排序很重要，因为我们之后需要反转解码的过程并生成与输入相同的输出。如果输入的字典没有正确的排序，我们将会失去错误排序部分的信息。

## 编码

现在，让我们反转这个过程，这样我们就可以用C#生成用BEncoded格式的输出。我们准备使用MemoryStream来生产字节数组。使用EncodeNextObject()方法来鉴别当前对象的类型，并且调用相关的编码方法，这样我们就可以递归编码。

我们将会给MemorySream增加一些扩展，让生成的字节数组更加整洁。

### 数字

只有long类型的数字才能编码，简单的在其前面加一个i，然后将数字转化为UTF-8字符串，最后加上结尾字符e

### 字节数组&字符串

对于字节数组我们把数组长度转化为字符串，然后后面接一个a，然后接上数字本身。处理字符串的时候，先把字符串转化为字节数组，然后按同样的方式处理

### 链表

处理链表的方式很直接，我们添加初始的l，然后将其中每个元素编码，最后添加e。

### 字典

字典的处理也使用相似的方式，开头增加d，之后的每个键值对编码，最后加上e。在C#中，字典是不能排序的，在遍历Dictionary的时候，没有顺序的假设。因此我们把key排好序之后再遍历他们，获取他们的值。

## 种子

现在我们有了BEncoing解码器，我们现在回到之前的种子文件，然后把他解析为C#的数据格式

```C#
d
  8:announce            33:http://192.168.1.74:6969/announce
  7:comment             17:Comment goes here
  10:created by         25:Transmission/2.92 (14714)
  13:creation date      i1460444420e
  8:encoding            5:UTF-8
  4:info              
    d
      6:length          i59616e
      4:name            9:lorem.txt
      12:piece length   i32768e
      6:pieces          40:L@fR���3�K*Ez�>_YS��86��"�&�p�<�6�C{�9G
      7:private         i0e
    e
e
```

让我们一个个看看这些项并且决定如何存储

- announce：这个是我们需要追踪的url，可以是一个url也可以是一个url列表(List<Tracker>)
- comment：用户特殊的说明(string)
- created by：创建者(用户或者软件)(string)
- creation date：创建时间(DateTime)
- encoding：编码格式(System.Text.Encoding)
- info：我们希望分享的文件信息
  - length：文件按的大小(字节)(long)，一个种子可以包含一个或者多个文件，因此使用List<FileItem>
  - name：文件名(string)
  - piece length：文件块的大小(字节)通常是2的倍数(int)
  - pieces：由每一块生成的一个长度为20的SHA1字符串，连在一起变成一个大的字节数组(byte[][])
  - private：文件是否是私人的(bool)

## 数据结构

我们来创建一个简单的类来表示这些信息

上面有提到两个帮助的类，第一个是FileItem，它存储每个文件的路径、大小、偏移量(即这个文件之前的文件大小总和)

```c#
public class FileItem
{            
    public string Path;
    public long Size;
    public long Offset;

    public string FormattedSize { get { return Torrent.BytesToString(Size); } }
}
```

第二个帮助类是Tracker，用来保存url，我们之后会在这个类中加更多的功能以便和tracker保持通信。

```c#
public class Tracker
{
    public event EventHandler<List<IPEndPoint>> PeerListUpdated;

    public string Address { get; private set; }

    public Tracker(string address)
    {
        Address = address;
    }
}
```

### 哈希

种子文件还需要另一块数据，一般称之为哈希值。这是一个种子文件info部分的字节SHA1哈希，用来标识种子。我们也增添了一些其他属性用来把infohash转化为16进制字符以及通过HTTP与tracker通信的时候所需要的版本

```c#
public byte[] Infohash { get; private set; } = new byte[20];
public string HexStringInfohash { get { return String.Join("", this.Infohash.Select(x => x.ToString("x2"))); } }
public string UrlSafeStringInfohash { get { return Encoding.UTF8.GetString(WebUtility.UrlEncodeToBytes(this.Infohash, 0, 20)); } }
```

### 片&块

种子文件中的文件放在列表中，被拆分为相同大小的片（最后一块可能会抛出异常）。可以通过字节的SHA1的哈希确认每片。

块是比片小的单元。片在传说的过程中可能太大因此传输的是更小的块。每块的大小不固定，因此我们的客户端可能传输不同打下的块给其他人。使用不同大小的块这点无关紧要因为每块由片的index，byte偏移量和长度确定。块只有在每片被验证的情况下请求或者发送，显然只有所有的块得到验证之后片才能得到验证。

我们增加一些变量和方法来保持追踪片和块在torrent中的大小和过程

```c#
public int BlockSize { get; private set; }
public int PieceSize { get; private set; }
public long TotalSize { get { return Files.Sum(x => x.Size); } }

public string FormattedPieceSize { get { return BytesToString(PieceSize); } }
public string FormattedTotalSize { get { return BytesToString(TotalSize); } }

public int PieceCount { get { return PieceHashes.Length; } }

public byte[][] PieceHashes { get; private set; }
public bool[] IsPieceVerified { get; private set; }
public bool[][] IsBlockAcquired { get; private set; }

public string VerifiedPiecesString { get { return String.Join("", IsPieceVerified.Select(x => x ? 1 : 0)); } }
public int VerifiedPieceCount { get { return IsPieceVerified.Count(x => x); } }
public double VerifiedRatio { get { return VerifiedPieceCount / (double)PieceCount; } }
public bool IsCompleted { get { return VerifiedPieceCount == PieceCount; } }
public bool IsStarted { get { return VerifiedPieceCount > 0; } }

public long Uploaded { get; set; } = 0;
public long Downloaded { get { return PieceSize * VerifiedPieceCount; } } // !! incorrect
public long Left { get { return TotalSize - Downloaded; } }

public int GetPieceSize(int piece)
{            
    if (piece == PieceCount - 1)
    { 
        int remainder = Convert.ToInt32(TotalSize % PieceSize);
        if (remainder != 0)
            return remainder;
    }

    return PieceSize;
}

public int GetBlockSize(int piece, int block)
{
    if (block == GetBlockCount(piece) - 1)
    {
        int remainder = Convert.ToInt32(GetPieceSize(piece) % BlockSize);
        if (remainder != 0)
            return remainder;
    }

    return BlockSize;
}

public int GetBlockCount(int piece)
{
    return Convert.ToInt32(Math.Ceiling(GetPieceSize(piece) / (double)BlockSize));
}
```

### 配置

Torrent类的构造函数需要种子文件信息部分的所有数据，它设置跟踪器，加载或者创建单个哈希块，验证下载进度

还有一个PeerListUpdated事件，每当跟踪器接收到更新的peer列表时，它就会被触发。

```C#
![files](D:\myDocuments\pics\files.png)public event EventHandler<List<IPEndPoint>> PeerListUpdated;

private object[] fileWriteLocks;
private static SHA1 sha1 = SHA1.Create();
  
public Torrent(string name, string location, List<FileItem> files, List<string> trackers, int pieceSize, byte[] pieceHashes = null, int blockSize = 16384, bool? isPrivate = false )
{       
    Name = name;
    DownloadDirectory = location;
    Files = files;
    fileWriteLocks = new object[Files.Count];
    for (int i = 0; i < this.Files.Count; i++)
        fileWriteLocks[i] = new object();   

    if (trackers != null)
    {
        foreach (string url in trackers)
        {
            Tracker tracker = new Tracker(url);
            Trackers.Add(tracker);
            tracker.PeerListUpdated += HandlePeerListUpdated;
        }
    }

    PieceSize = pieceSize;
    BlockSize = blockSize;
    IsPrivate = isPrivate;

    int count = Convert.ToInt32(Math.Ceiling(TotalSize / Convert.ToDouble(PieceSize)));

    PieceHashes = new byte[count][];
    IsPieceVerified = new bool[count];
    IsBlockAcquired = new bool[count][];

    for (int i = 0; i < PieceCount; i++)
        IsBlockAcquired[i] = new bool[GetBlockCount(i)];            

    if (pieceHashes == null)
    {
        // this is a new torrent so we have to create the hashes from the files                 
        for (int i = 0; i < PieceCount; i++)
            PieceHashes[i] = GetHash(i);
    }
    else
    {
        for (int i = 0; i < PieceCount; i++)
        {
            PieceHashes[i] = new byte[20];
            Buffer.BlockCopy(pieceHashes, i * 20, PieceHashes[i], 0, 20);
        }
    }

    object info = TorrentInfoToBEncodingObject(this);
    byte[] bytes =  BEncoding.Encode(info);
    Infohash = SHA1.Create().ComputeHash(bytes);

    for (int i = 0; i < PieceCount; i++)
        Verify(i);
}
```

### 读&写

根据下面的表格可以看到，片和块不在乎一个文件何时结束下一个文件还是开始。单个片中可以包含任意数量的文件。

![img](https://media.seanjoflynn.com/images/research/bittorrent/files.png)

我们的Read()和Write()方法只需要开始位置和字节长度。方法都很相似都是选择一个片然后计算出开始和结束的位置，然后循环读取或者写入。Read()方法加载文件的字节到buffer里面然后返回它。读方法将给予的byte[]分块然后将他们写到每个文件正确的位置。我们也加入了lock来防止同时写入一个文件。

```C#
public byte[] Read(long start, int length)
{
    long end = start + length;
    byte[] buffer = new byte[length];

    for (int i=0; i<Files.Count; i++)
    {                
        if ((start < Files[i].Offset && end < Files[i].Offset) ||
            (start > Files[i].Offset + Files[i].Size && end > Files[i].Offset + Files[i].Size))
            continue;

        string filePath = DownloadDirectory + Path.DirectorySeparatorChar + FileDirectory + Files[i].Path;

        if (!File.Exists(filePath))
            return null;

        long fstart = Math.Max(0, start - Files[i].Offset);
        long fend = Math.Min(end - Files[i].Offset, Files[i].Size);
        int flength = Convert.ToInt32(fend - fstart);
        int bstart = Math.Max(0, Convert.ToInt32(Files[i].Offset - start));

        using (Stream stream = new FileStream(filePath, FileMode.Open, FileAccess.Read, FileShare.ReadWrite))
        {                    
            stream.Seek(fstart, SeekOrigin.Begin);
            stream.Read(buffer, bstart, flength);
        }
    }

    return buffer;
}

public void Write(long start, byte[] bytes)
{
    long end = start + bytes.Length;

    for (int i = 0; i < Files.Count; i++)
    {                
        if ((start < Files[i].Offset && end < Files[i].Offset) ||
            (start > Files[i].Offset + Files[i].Size && end > Files[i].Offset + Files[i].Size))
            continue;

        string filePath = DownloadDirectory + Path.DirectorySeparatorChar + FileDirectory + Files[i].Path;

        string dir = Path.GetDirectoryName(filePath);
        if (!Directory.Exists(dir))
            Directory.CreateDirectory(dir);

        lock (fileWriteLocks[i])
        {
            using (Stream stream = new FileStream(filePath, FileMode.OpenOrCreate, FileAccess.ReadWrite))
            {
                long fstart = Math.Max(0, start - Files[i].Offset);
                long fend = Math.Min(end - Files[i].Offset, Files[i].Size);
                int flength = Convert.ToInt32(fend - fstart);
                int bstart = Math.Max(0, Convert.ToInt32(Files[i].Offset - start));

                stream.Seek(fstart, SeekOrigin.Begin);
                stream.Write(bytes, bstart, flength);
            }
        }
    }
}
```

下面是一写读写的帮助函数

```c#
public byte[] ReadPiece(int piece)
{
    return Read(piece * PieceSize, GetPieceSize(piece));
}

public byte[] ReadBlock(int piece, int offset, int length)
{
    return Read(piece * PieceSize + offset, length);
}

public void WriteBlock(int piece, int block, byte[] bytes)
{            
    Write(piece * PieceSize + block * BlockSize, bytes);
    IsBlockAcquired[piece][block] = true;
    Verify(piece);
}
```

每一片的验证都是间接的，一个很重要需要注意的事情就是如果我们获取了所有的块但是验证失败了，就要将这些块重置然后重更新获取他们

```C#
public event EventHandler<int> PieceVerified;
  
public void Verify(int piece)
{
    byte[] hash = GetHash(piece);

    bool isVerified = (hash != null && hash.SequenceEqual(PieceHashes[piece]));

    if (isVerified)
    {                
        IsPieceVerified[piece] = true;

        for (int j = 0; j < IsBlockAcquired[piece].Length; j++)
            IsBlockAcquired[piece][j] = true;

        var handler = PieceVerified;
        if (handler != null)
            handler(this, piece);

        return;
    }

    IsPieceVerified[piece] = false;

    // reload the entire piece
    if (IsBlockAcquired[piece].All(x => x))
    {
        for (int j = 0; j < IsBlockAcquired[piece].Length; j++)
            IsBlockAcquired[piece][j] = false;
    }
}

public byte[] GetHash(int piece)
{
    byte[] data = ReadPiece(piece);

    if (data == null)
        return null;            

    return sha1.ComputeHash(data);
}
```

### 导入&导出

加载和保存种子文件的方式很简单

```C#
public static Torrent LoadFromFile(string filePath, string downloadPath)
{
    object obj = BEncoding.DecodeFile(filePath);
    string name = Path.GetFileNameWithoutExtension(filePath);

    return BEncodingObjectToTorrent(obj, name, downloadPath);
}

public static void SaveToFile(Torrent torrent)
{
    object obj = TorrentToBEncodingObject(torrent);

    BEncoding.EncodeToFile(obj, torrent.Name + ".torrent");
}
```

将种子文件和BEncoding对象转换的工作是最为繁琐的。将信息部分编码的工作在TorrentInfoToBEncodingObject()方法中被拆分了这样我们就可以利用它生成infohashes

```c#
public static long DateTimeToUnixTimestamp( DateTime time )
{
    return Convert.ToInt64((DateTime.UtcNow.Subtract(new DateTime(1970, 1, 1))).TotalSeconds);
}

private static object TorrentToBEncodingObject(Torrent torrent)
{
    Dictionary<string,object> dict = new Dictionary<string, object>();

    if( torrent.Trackers.Count == 1 )
        dict["announce"] = Encoding.UTF8.GetBytes(torrent.Trackers[0].Address);
    else
        dict["announce"] = torrent.Trackers.Select(x => (object)Encoding.UTF8.GetBytes(x.Address)).ToList();
    dict["comment"] = Encoding.UTF8.GetBytes(torrent.Comment);
    dict["created by"] = Encoding.UTF8.GetBytes(torrent.CreatedBy);
    dict["creation date"] = DateTimeToUnixTimestamp(torrent.CreationDate);
    dict["encoding"] = Encoding.UTF8.GetBytes(Encoding.UTF8.WebName.ToUpper());
    dict["info"] = TorrentInfoToBEncodingObject(torrent);

    return dict;
}

private static object TorrentInfoToBEncodingObject(Torrent torrent)
{
    Dictionary<string,object> dict = new Dictionary<string, object>();

    dict["piece length"] = (long)torrent.PieceSize;
    byte[] pieces = new byte[20 * torrent.PieceCount];
    for (int i = 0; i < torrent.PieceCount; i++)
        Buffer.BlockCopy(torrent.PieceHashes[i], 0, pieces, i * 20, 20);
    dict["pieces"] = pieces;

    if (torrent.IsPrivate.HasValue)
        dict["private"] = torrent.IsPrivate.Value ? 1L : 0L;

    if (torrent.Files.Count == 1)
    {                
        dict["name"] = Encoding.UTF8.GetBytes(torrent.Files[0].Path);
        dict["length"] = torrent.Files[0].Size;
    }
    else
    {
        List<object> files = new List<object>();

        foreach (var f in torrent.Files)
        {
            Dictionary<string,object> fileDict = new Dictionary<string, object>();
            fileDict["path"] = f.Path.Split(Path.DirectorySeparatorChar).Select(x => (object)Encoding.UTF8.GetBytes(x)).ToList();
            fileDict["length"] = f.Size;
            files.Add(fileDict);
        }

        dict["files"] = files;
        dict["name"] = Encoding.UTF8.GetBytes(torrent.FileDirectory.Substring(0, torrent.FileDirectory.Length - 1));
    }

    return dict;
}
```

将BEncoding对象和种子文件转换

```c#
public static string DecodeUTF8String( object obj )
{
    byte[] bytes = obj as byte[];

    if (bytes == null)
        throw new Exception("unable to decode utf-8 string, object is not a byte array");

    return Encoding.UTF8.GetString(bytes);
}

public static DateTime UnixTimeStampToDateTime( double unixTimeStamp )
{
    // Unix timestamp is seconds past epoch
    System.DateTime dtDateTime = new DateTime(1970,1,1,0,0,0,0,System.DateTimeKind.Utc);
    dtDateTime = dtDateTime.AddSeconds( unixTimeStamp ).ToLocalTime();
    return dtDateTime;
}

private static Torrent BEncodingObjectToTorrent(object bencoding, string name, string downloadPath)
{
    Dictionary<string,object> obj = (Dictionary<string,object>)bencoding;

    if (obj == null)
        throw new Exception("not a torrent file");
    
    // !! handle list
    List<string> trackers = new List<string>();
    if (obj.ContainsKey("announce"))                
        trackers.Add(DecodeUTF8String(obj["announce"]));            

    if (!obj.ContainsKey("info"))
        throw new Exception("Missing info section");

    Dictionary<string,object> info = (Dictionary<string,object>)obj["info"];

    if (info == null)
        throw new Exception("error");

    List<FileItem> files = new List<FileItem>();

    if (info.ContainsKey("name") && info.ContainsKey("length"))
    {
        files.Add(new FileItem() {
            Path = DecodeUTF8String(info["name"]),
            Size = (long)info["length"]
        });
    }
    else if (info.ContainsKey("files"))
    {
        long running = 0;

        foreach (object item in (List<object>)info["files"])
        {
            var dict = item as Dictionary<string,object>;

            if (dict == null || !dict.ContainsKey("path") || !dict.ContainsKey("length") )
                throw new Exception("error: incorrect file specification");

            string path = String.Join(Path.DirectorySeparatorChar.ToString(), ((List<object>)dict["path"]).Select(x => DecodeUTF8String(x)));

            long size = (long)dict["length"];

            files.Add(new FileItem() {
                Path = path,
                Size = size,
                Offset = running
            });

            running += size;
        }
    }
    else
    {
        throw new Exception("error: no files specified in torrent");
    }
        
    if (!info.ContainsKey("piece length"))
        throw new Exception("error");
    int pieceSize = Convert.ToInt32(info["piece length"]);

    if (!info.ContainsKey("pieces"))
        throw new Exception("error");            
    byte[] pieceHashes = (byte[])info["pieces"];

    bool? isPrivate = null;
    if (info.ContainsKey("private"))
        isPrivate = ((long)info["private"]) == 1L;            
    
    Torrent torrent = new Torrent(name, downloadPath, files, trackers, pieceSize, pieceHashes, 16384, isPrivate );

    if (obj.ContainsKey("comment"))
        torrent.Comment = DecodeUTF8String(obj["comment"]);

    if (obj.ContainsKey("created by"))
        torrent.CreatedBy = DecodeUTF8String(obj["created by"]);

    if (obj.ContainsKey("creation date"))
        torrent.CreationDate = UnixTimeStampToDateTime(Convert.ToDouble(obj["creation date"]));

    if (obj.ContainsKey("encoding"))
        torrent.Encoding = Encoding.GetEncoding(DecodeUTF8String(obj["encoding"]));
    
    return torrent;
}
```

### 创建

如果我们想要创建我们自己的种子文件，我们可以使用Create()方法，可以传入单个文件路径或者目录

```c#
public static Torrent Create(string path, List<string> trackers = null, int pieceSize = 32768, string comment = "")
{
    string name = "";
    List<FileItem> files = new List<FileItem>();

    if (File.Exists(path))
    {
        name = Path.GetFileName(path);

        long size = new FileInfo(path).Length;
        files.Add(new FileItem()
            {
                Path = Path.GetFileName(path),
                Size = size
            });
    }
    else
    {
        name = path;
        string directory = path + Path.DirectorySeparatorChar;

        long running = 0;
        foreach (string file in Directory.EnumerateFiles(path, "*.*", SearchOption.AllDirectories))
        {
            string f = file.Substring(directory.Length);

            if (f.StartsWith("."))
                continue;

            long size = new FileInfo(file).Length;

            files.Add(new FileItem()
                {
                    Path = f,
                    Size = size,
                    Offset = running
                });
            
            running += size;
        }
    }

    Torrent torrent = new Torrent(name, "", files, trackers, pieceSize);
    torrent.Comment = comment;
    torrent.CreatedBy = "TestClient";
    torrent.CreationDate = DateTime.Now;
    torrent.Encoding = Encoding.UTF8;

    return torrent;
}
```

## 追踪器

一旦我们已经准备好了所有的种子信息，我们应该如何寻找对象去连接？我们连接到追踪器的原因有两个，一个是他可以提供一个可以立刻尝试连接的追踪器列表。其次他会把我们加入对象列表中这样之后的新对象可以获得我们的ip地址和相应的端口号。我们要也可以获取当前的文件进度告诉他，一边可以追踪种子和预下载者的数量

### 宣告

跟踪器的最基本版本就是具有单个节点的HTTP服务器，我们本地运行的opentracker使用http://localhost:6969/announce端点，我们需要在HTTP GET请求中加一些参数

- infohash：这是我们种子的哈希，任何影响url的原始字节都需要转义，由UrlSafeStringInfohash属性提供
- peer_id：一个20比特的字符串来验证。大部分客户端使用少量字符来验证程序和版本，随后跟着一些随机字符。我们打算使用随机的数字组成的字符串
- port：监听传入连接的端口
- uploaded：已经上传的的字节数
- downloaded：已经下载的字节数
- left：还剩余需要下载的字节数
- event：当前客户端的状态，started、paused 、stopped。这样追踪器就知道是否需要把我们从对象中加入或者移除
- compact：0或1代表返回compact对象列表，opentracker似乎只能在compact模式下运作

我们可以使用curl来测试request在我们构建之前

```shell
$ curl -v "http://192.168.1.74:6969/announce?info_hash=%3E%09%D0%1CHHCy%CF%27%F23%24%E1%7B%BDijbD&peer_id=76433642664923430920&port=56723&uploaded=0&downloaded=0&left=0&event=started&compact=1"
*   Trying 192.168.1.74...
* Connected to 192.168.1.74 (192.168.1.74) port 6969 (#0)
> GET /announce?info_hash=%3E%09%D0%1CHHCy%CF%27%F23%24%E1%7B%BDijbD&peer_id=76433642664923430920&port=56723&uploaded=0&downloaded=0&left=0&event=started&compact=1 HTTP/1.1
> Host: 192.168.1.74:6969
> User-Agent: curl/7.43.0
> Accept: */*
> 
< HTTP/1.1 200 OK
< Content-Type: text/plain
< Content-Length: 111
< 
* Connection #0 to host 192.168.1.74 left intact
d8:completei2e10:downloadedi0e10:incompletei1e8:intervali1769e12:min intervali884e5:peers18:??J??Jݓ??J??e
```

结果是BEncoded 对象，将其格式化

```shell
d
  8:complete        i2e
  10:downloaded     i0e
  10:incomplete     i1e
  8:interval        i1769e
  12:min interval   i884e
  5:peers           18:??J??Jݓ??J??
e
```

一个个看reponse

- complete：拥有完整文件的对象数量
- downloaded：没有找到相关资料
- incomplete：没有完整文件的对象数量（预下载者）
- interval：客户端从追踪器请求更新对象列表的频率
- min interval：客户端从追踪器请求更新对象列表的最小频率
- peers：在紧凑模式下，是一个byte[]。每6个字节就是一个对象-前四个数字代表IPV4的地址，最后两个代表端口号

让我们在自己的代码中重现这些功能，首先为事件类型创建一个简单的枚举类

```c#
public enum TrackerEvent
{
    Started,
    Paused,
    Stopped
}
```

我们重新看Tracker类并且加入announcing的逻辑。我们的Update()方法创造需要的url。我增加了一个检查来防止过于频繁的检查新的对象。我们还需要一个方法来重置时钟

```c#
public DateTime LastPeerRequest { get; private set; } = DateTime.MinValue;
public TimeSpan PeerRequestInterval { get; private set; } = TimeSpan.FromMinutes(30);

public void Update(Torrent torrent, TrackerEvent ev, string id, int port)
{
    // wait until after request interval has elapsed before asking for new peers
    if (ev == TrackerEvent.Started && DateTime.UtcNow < LastPeerRequest.Add(PeerRequestInterval))
        return;

    LastPeerRequest = DateTime.UtcNow;

    string url = String.Format("{0}?info_hash={1}&peer_id={2}&port={3}&uploaded={4}&downloaded={5}&left={6}&event={7}&compact=1", 
                     Address, torrent.UrlSafeStringInfohash,
                     id, port,
                     torrent.Uploaded, torrent.Downloaded, torrent.Left, 
                     Enum.GetName(typeof(TrackerEvent), ev).ToLower());
    
    Request(url);
}

public void ResetLastRequest()
{
    LastPeerRequest = DateTime.MinValue;
}
```

Request()方法创建真正的HTTP 请求。HttpWebResponse.BeginGetResponse是异步的因此不会阻塞线程。我们可以简单指定一个回调函数(HandleResponse)当追踪器获得回复的时候获取值。我们读取返回的字节，并用BEncoding.Decode()处理。最后，我们解析时间间隔和对象列表来触发PeerListUpdated事件

```c#
private void Request( string url )
{
    httpWebRequest = (HttpWebRequest)HttpWebRequest.Create(url);
    httpWebRequest.BeginGetResponse(HandleResponse, null);
}

private void HandleResponse(IAsyncResult result)
{
    byte[] data;

    using (HttpWebResponse response = (HttpWebResponse)httpWebRequest.EndGetResponse(result))
    {
        if (response.StatusCode != HttpStatusCode.OK)
        {
            Console.WriteLine("error reaching tracker " + this + ": " + response.StatusCode + " " + response.StatusDescription);
            return;
        }
    
        using (Stream stream = response.GetResponseStream())
        {
            data = new byte[response.ContentLength];
            stream.Read(data, 0, Convert.ToInt32(response.ContentLength));
        }
    }

    Dictionary<string,object> info = BEncoding.Decode(data) as Dictionary<string,object>;

    if (info == null)
    {
        Console.WriteLine("unable to decode tracker announce response");
        return;
    }

    PeerRequestInterval = TimeSpan.FromSeconds((long)info["interval"]);
    byte[] peerInfo = (byte[])info["peers"];
        
    List<IPEndPoint> peers = new List<IPEndPoint>();
    for (int i = 0; i < peerInfo.Length/6; i++)
    {
        int offset = i * 6;
        string address = peerInfo[offset] + "." + peerInfo[offset+1] + "." + peerInfo[offset+2] + "." + peerInfo[offset+3];
        int port = EndianBitConverter.Big.ToChar(peerInfo, offset + 4);

        peers.Add(new IPEndPoint(IPAddress.Parse(address), port));
    }

    var handler = PeerListUpdated;
    if (handler != null)
        handler(this, peers);
}
```

这些就是Tracker类中的内容，我们将会继续在Torrent类中更新其中所有的追踪器

```c#
public void UpdateTrackers(TrackerEvent ev, string id, int port)
{
    foreach (var tracker in Trackers)
        tracker.Update(this, ev, id, port);
}

public void ResetTrackersLastUpdated()
{}
```

## 对象

对象之间直接通信。他们打开TCP连接来允许同时收发消息

### 结构

这里面有很多内容，但拆分开来之后不算太糟。我们有一些事件当对象断开连接，他的状态改变或者有数据到达。我们存储一些TCP网络变量来处理从对象那边的字节数据。我们还用一些变量存储对象的状态和进程。我们还追踪我们发出的等待响应的数据请求。最后，我们用一些变量来追踪有多少数据在我们之间转换完成。

```c#
using System;
using System.Collections;
using System.Collections.Concurrent;
using System.Collections.Generic;
using System.Net;
using System.Net.Sockets;
using System.Linq;
using System.Text;
using System.IO;
using MiscUtil.Conversion;

namespace BitTorrent
{
    public class Peer
    {
        public event EventHandler Disconnected;
        public event EventHandler StateChanged;
        public event EventHandler<DataRequest> BlockRequested;
        public event EventHandler<DataRequest> BlockCancelled;
        public event EventHandler<DataPackage> BlockReceived;

        public string LocalId { get; set; }
        public string Id { get; set; }

        public Torrent Torrent { get; private set; }

        public IPEndPoint IPEndPoint { get; private set; }
        public string Key { get { return IPEndPoint.ToString(); } }

        private TcpClient TcpClient { get; set; }
        private NetworkStream stream { get; set; }
        private const int bufferSize = 256;
        private byte[] streamBuffer = new byte[bufferSize];
        private List<byte> data = new List<byte>();

        public bool[] IsPieceDownloaded = new bool[0];
        public string PiecesDownloaded { get { return String.Join("", IsPieceDownloaded.Select(x => Convert.ToInt32(x))); } }
        public int PiecesRequiredAvailable { get { return IsPieceDownloaded.Select((x, i) => x && !Torrent.IsPieceVerified[i]).Count(x => x); } }
        public int PiecesDownloadedCount { get { return IsPieceDownloaded.Count(x => x); } }
        public bool IsCompleted { get { return PiecesDownloadedCount == Torrent.PieceCount; } }

        public bool IsDisconnected;

        public bool IsHandshakeSent;
        public bool IsPositionSent;
        public bool IsChokeSent = true;
        public bool IsInterestedSent = false;

        public bool IsHandshakeReceived;
        public bool IsChokeReceived = true;
        public bool IsInterestedReceived = false;

        public bool[][] IsBlockRequested = new bool[0][];
        public int BlocksRequested { get { return IsBlockRequested.Sum(x => x.Count(y => y)); } }

        public DateTime LastActive;
        public DateTime LastKeepAlive = DateTime.MinValue;

        public long Uploaded;
        public long Downloaded;
    }
}
```

一个对象可以用两种方式创建，我们可以打开连接（这样我们可以指定一个IPEndPoint去连接）或者他们可以打开连接（这样我们就可以接受TcpCLient）

```c#
public Peer(Torrent torrent, string localId, TcpClient client) : this(torrent, localId)
{            
    TcpClient = client;
    IPEndPoint = (IPEndPoint)client.Client.RemoteEndPoint;
}

public Peer(Torrent torrent, string localId, IPEndPoint endPoint): this(torrent, localId)
{
    IPEndPoint = endPoint;
}

private Peer(Torrent torrent, string localId)
{
    LocalId = localId;
    Torrent = torrent;

    LastActive = DateTime.UtcNow;
    IsPieceDownloaded = new bool[Torrent.PieceCount];
    IsBlockRequested = new bool[Torrent.PieceCount][];
    for (int i = 0; i < Torrent.PieceCount; i++)
        IsBlockRequested[i] = new bool[Torrent.GetBlockCount(i)];
}
```

## 协议

对象之间的协议很简单

### 握手

初始时双方都需要发一个握手请求，这制定了他们可以使用相同的扩展协议，并确认他们使用的是相同的种子

### 进度

在握手之后，他们必须立刻确认对方下载种子的进度。之后进度的任何改变都必须要立刻通信

### 状态

所有对象一开始not interested和choked。如果一个对象想要请求数据，他通知一个对象他interested。如果那个对象愿意回复信息请求，他会通知那个对象他unchocked。对象使用这些状态为了限制传播者和接收者的数量，以防拥塞和管理带宽。

### 日期

一旦一个对象unchocked，他可以开始请求数据块。其他对象将会回复这些请求。一些对象可能从不同的对象中请求同一块数据因此如果之前已经获得过可以根据日期来取消请求。

## 连接

一旦我们的对象安装好，我们就开始异步的获取即将到来的数据，我们也可以立刻发生我们的握手（如果我们收到了他们的握手信息，还会发送位置信息）

```c#
public void Connect()
{
    if (TcpClient == null)
    {
        TcpClient = new TcpClient();
        try
        {
            TcpClient.Connect(IPEndPoint);
        }
        catch (Exception e)
        {
            Disconnect();
            return;
        }
    }

    Log.WriteLine(this, "connected");

    stream = TcpClient.GetStream();
    stream.BeginRead(streamBuffer, 0, Peer.bufferSize, new AsyncCallback(HandleRead), null);

    SendHandshake();
    if (IsHandshakeReceived)
        SendBitfield(Torrent.IsPieceVerified);
}
```

除了关闭TCP连接之外，没有协议可以断开与对象的连接，我们还会触发Disconnected事件

```c#
public void Disconnect()
{
    if (!IsDisconnected)
    {
        IsDisconnected = true;
        Log.WriteLine(this, "disconnected, down " + Downloaded + ", up " + Uploaded);
    }

    if (TcpClient != null)
        TcpClient.Close();

    if (Disconnected != null)
        Disconnected(this, new EventArgs());
}
```

为了发送字节，我们简单的将其写入网络流，没有办法通知一个TCP连接是关闭还是开放，因此我们将其放入try...catch之中防止他关闭。

```c#
private void SendBytes(byte[] bytes)
{
    try
    {
        stream.Write(bytes, 0, bytes.Length);
    }
    catch(Exception e)
    {
        Disconnect();
    }
}
```

当我们从流中读取数据的时候，我们把到来的字节放在一个列表中。一旦我们有了足够多的字节，我们确认这些信息的长度，并一直等待，直到它被接收。一旦接收到一个完整的信息，我们对他解码和处理。如果一次读取中含有多个信息，我们就循环处理他们直到结束。

```c#
private void HandleRead( IAsyncResult ar )
{            
    int bytes = 0;
    try
    {
        bytes = stream.EndRead(ar);
    }
    catch (Exception e)
    {
        Disconnect();
        return;
    }
       
    data.AddRange(streamBuffer.Take(bytes));

    int messageLength = GetMessageLength(data);
    while (data.Count >= messageLength)
    {
        HandleMessage(data.Take(messageLength).ToArray());
        data = data.Skip(messageLength).ToList();

        messageLength = GetMessageLength(data);
    }

    try
    {
        stream.BeginRead(streamBuffer, 0, Peer.bufferSize, new AsyncCallback(HandleRead), null);
    }
    catch (Exception e)
    {
        Disconnect();
    }
}

private int GetMessageLength(List<byte> data)
{
    if (!IsHandshakeReceived)
        return 68;

    if (data.Count < 4)
        return int.MaxValue;

    return EndianBitConverter.Big.ToInt32(data.ToArray(), 0) + 4;
}
```

### 消息种类

有10中消息类型有一个字节来表示他们，其他两种被认为是显而易见的。消息类型被一个字节定义。我们准备定义它为int枚举这样我们就可以使用负值标识是否是其他两种类型。我不想将其保持为其保留字节，而是为为生命的类型可能使用的最高值（255及一下），因为这些只可能在未来的规范中为新消息类型定义。

```c#
public enum MessageType : int
{
    Unknown = -3,
    Handshake = -2,
    KeepAlive = -1,
    Choke = 0,
    Unchoke = 1,
    Interested = 2,
    NotInterested = 3,
    Have = 4,
    Bitfield = 5,
    Request = 6,
    Piece = 7,
    Cancel = 8,
    Port = 9,
}
```

### 编码&解码

#### 握手

从一个新的对象那边获得的第一个消息一定要是一个握手消息，它包含这个对象支持的特性，客户端的id和确认种子文件的infohash、

注意到不像其他信息，握手信息的长度被定义为单个byte而不是int（4个字节），并且总是设定为19，即使握手消息的长度是68个字节

![img](https://media.seanjoflynn.com/images/research/bittorrent/handshake.png)

```c#
public static bool DecodeHandshake(byte[] bytes, out byte[] hash, out string id)
{
    hash = new byte[20];
    id = "";

    if (bytes.Length != 68 || bytes[0] != 19)
    {
        Log.WriteLine("invalid handshake, must be of length 68 and first byte must equal 19");
        return false;
    }

    if (Encoding.UTF8.GetString(bytes.Skip(1).Take(19).ToArray()) != "BitTorrent protocol")
    {
        Log.WriteLine("invalid handshake, protocol must equal \"BitTorrent protocol\"");
        return false;
    }

    // flags
    //byte[] flags = bytes.Skip(20).Take(8).ToArray();

    hash = bytes.Skip(28).Take(20).ToArray();

    id = Encoding.UTF8.GetString(bytes.Skip(48).Take(20).ToArray());

    return true;
}

public static byte[] EncodeHandshake(byte[] hash, string id)
{
    byte[] message = new byte[68];
    message[0] = 19;
    Buffer.BlockCopy(Encoding.UTF8.GetBytes("BitTorrent protocol"), 0, message, 1, 19);
    Buffer.BlockCopy(hash,0, message, 28, 20);
    Buffer.BlockCopy(Encoding.UTF8.GetBytes(id), 0, message, 48, 20);

    return message;
}
```

#### 保持通信

保持通信消息是一个没有正文的信息，即其长度为0。

![img](https://media.seanjoflynn.com/images/research/bittorrent/keep-alive.png)

```c#
public static bool DecodeKeepAlive(byte[] bytes)
{            
    if (bytes.Length != 4 || EndianBitConverter.Big.ToInt32(bytes,0) != 0 )
    {
        Log.WriteLine("invalid keep alive");
        return false;
    }
    return true;
}

public static byte[] EncodeKeepAlive()
{
    return EndianBitConverter.Big.GetBytes(0);
}
```

#### 状态

四个状态消息都是1个字节长度，它指示MessageType以及状态的变化。下面的是一个not-interested消息

![img](https://media.seanjoflynn.com/images/research/bittorrent/state.png)

```c#
public static bool DecodeChoke(byte[] bytes)
{            
    return DecodeState(bytes, MessageType.Choke);
}

public static bool DecodeUnchoke(byte[] bytes)
{            
    return DecodeState(bytes, MessageType.Unchoke);
}

public static bool DecodeInterested(byte[] bytes)
{            
    return DecodeState(bytes, MessageType.Interested);
}

public static bool DecodeNotInterested(byte[] bytes)
{            
    return DecodeState(bytes, MessageType.NotInterested);
}

public static bool DecodeState(byte[] bytes, MessageType type)
{            
    if (bytes.Length != 5 || EndianBitConverter.Big.ToInt32(bytes, 0) != 1 || bytes[4] != (byte)type)
    {
        Log.WriteLine("invalid " + Enum.GetName(typeof(MessageType), type));
        return false;
    }
    return true;
}

public static byte[] EncodeChoke() 
{
    return EncodeState(MessageType.Choke);
}

public static byte[] EncodeUnchoke() 
{
    return EncodeState(MessageType.Unchoke);
}

public static byte[] EncodeInterested()
{
    return EncodeState(MessageType.Interested);
}

public static byte[] EncodeNotInterested() 
{
    return EncodeState(MessageType.NotInterested);
}

public static byte[] EncodeState(MessageType type) 
{
    byte[] message = new byte[5];
    Buffer.BlockCopy(EndianBitConverter.Big.GetBytes(1), 0, message, 0, 4);
    message[4] = (byte)type;
    return message;
}
```

#### 进度

have消息指定一片下标用来和对象通信是否下载完成或者验证完成

![img](https://media.seanjoflynn.com/images/research/bittorrent/have.png)

bitfield消息是一个快速和对象进度通信的方式通常是在握手后发生，是一个小追踪器，在类型字节之后，每个字节指定是否对象以及下载了对应片的下标

![img](https://media.seanjoflynn.com/images/research/bittorrent/bitfield.png)

因此在上面的例子中，字节的值是200，如果将其转换为二进制就是1001000。

在这个特殊的例子中，对象1，2，5片下载好之后进行了通信。如果片所代表的数字不能被8整除，bitfield的末尾用0填充。

```c#
public static bool DecodeHave(byte[] bytes, out int index)
{
    index = -1;

    if (bytes.Length != 9 || EndianBitConverter.Big.ToInt32(bytes, 0) != 5)
    {
        Log.WriteLine("invalid have, first byte must equal 0x2");
        return false;
    }

    index = EndianBitConverter.Big.ToInt32(bytes, 5);

    return true;
}

public static bool DecodeBitfield(byte[] bytes, int pieces, out bool[] isPieceDownloaded)
{
    isPieceDownloaded = new bool[pieces];

    int expectedLength = Convert.ToInt32(Math.Ceiling(pieces / 8.0)) + 1;

    if (bytes.Length != expectedLength + 4 || EndianBitConverter.Big.ToInt32(bytes,0) != expectedLength)
    {
        Log.WriteLine("invalid bitfield, first byte must equal " + expectedLength);
        return false;
    }

    BitArray bitfield = new BitArray(bytes.Skip(5).ToArray());

    for (int i = 0; i < pieces; i++)
        isPieceDownloaded[i] = bitfield[bitfield.Length - 1 - i];

    return true;
}

public static byte[] EncodeHave(int index) 
{            
    byte[] message = new byte[9];
    Buffer.BlockCopy(EndianBitConverter.Big.GetBytes(5), 0, message, 0, 4);
    message[4] = (byte)MessageType.Have;
    Buffer.BlockCopy(EndianBitConverter.Big.GetBytes(index), 0, message, 5, 4);

    return message;
}

public static byte[] EncodeBitfield(bool[] isPieceDownloaded) 
{
    int numPieces = isPieceDownloaded.Length;
    int numBytes = Convert.ToInt32(Math.Ceiling(numPieces / 8.0));
    int numBits = numBytes * 8;

    int length = numBytes + 1;

    byte[] message = new byte[length + 4];
    Buffer.BlockCopy(EndianBitConverter.Big.GetBytes(length), 0, message, 0, 4);
    message[4] = (byte)MessageType.Bitfield;

    bool[] downloaded = new bool[numBits];
    for (int i = 0; i < numPieces; i++)
        downloaded[i] = isPieceDownloaded[i];

    BitArray bitfield = new BitArray(downloaded);
    BitArray reversed = new BitArray(numBits);
    for (int i = 0; i < numBits; i++)
        reversed[i] = bitfield[numBits - i - 1];

    reversed.CopyTo(message, 5);

    return message;
}
```



