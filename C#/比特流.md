## BEncoding

让我们打开这个之前在记事本中创建的种子文件

```c#
d8:announce33:http://192.168.1.74:6969/announce7:comment17:Comment goes here10:created by25:Transmission/2.92 (14714)13:creation datei1460444420e8:encoding5:UTF-84:infod6:lengthi59616e4:name9:lorem.txt12:piece lengthi32768e6:pieces40:L@fR���3�K*Ez�>_YS��86��"�&�p�<�6�C{�9G7:privatei0eeexxxxxxxxxx d8:announce33:http://192.168.1.74:6969/announce7:comment17:Comment goes here10:created by25:Transmission/2.92 (14714)13:creation datei1460444420e8:encoding5:UTF-84:infod6:lengthi59616e4:name9:lorem.txt12:piece lengthi32768e6:pieces40:L@fR���3�K*Ez�>_YS��86��"�&�p�<�6�C{�9G7:privatei0eeeC

```

看起来很杂乱

## 解码

### 数字

如果知道下一个对象是数字，就遍历数组直到找到代表数字结尾的字母(e)，把这个过程中的bytes记录下来，然后我们把这些bytes先转化为string再转换为long。使用long的原因是因为有些数字代表文件的字节数，可能会大于int的最大值。

### 字符串

对于字符串，我们需要解析两个都独立的部分，第一个部分是标识字节数组长度的数字，第二部分是字节本身。因此首先，就遍历数组直到找到代表数字结尾的字母。在此使用do...while因为需要第一个字符。然后和解码数字过程一样，我们把这些bytes先转化为string再转换为int来得到长度。这个长度代表数组中有多少字节，我们可以遍历数组直到拿到所有字节。

### 链表

对于链表，我们简单的抓取下一个对象直到遇到结尾字符。我们不需要知道链表中的对象类型是什么，只需要将它们装进去。规范没有指定它们的所有项是否都是相同的类型，在我们的引用中，无需检查。

### 字典

字典采用同样的处理方法，唯一的不同支持就是，我们一次取出两个对象（一个key，一个value）然后把他们写入字典中，key必须是合法的UTF-8的字符串。

字典中的项必须按照key中的原始UTF-8字节排序  。这对于我们检查传入字典是否正确排序很重要，因为我们之后需要反转解码的过程并生成与输入相同的输出。如果输入的字典没有正确的排序，我们将会失去错误排序部分的信息。

## 编码

现在，让我们反转这个过程，这样我们就可以用C#生成用BEncoded格式的输出。我们准备使用MemoryStream来生产字节数组。使用EncodeNextObject()方法来鉴别当前对象的类型，并且调用相关的编码方法，这样我们就可以递归编码。

我们将会给MemorySream增加一些扩展，让生成的字节数组更加整洁。

### 数字

只有long类型的数字才能编码，简单的在其前面加一个i，然后将数字转化为UTF-8字符串，最后加上结尾字符e

### 字节数组&字符串

对于字节数组我们把数组长度转化为字符串，然后后面接一个a，然后接上数字本身。处理字符串的时候，先把字符串转化为字节数组，然后按同样的方式处理

### 链表

处理链表的方式很直接，我们添加初始的l，然后将其中每个元素编码，最后添加e。

### 字典

字典的处理也使用相似的方式，开头增加d，之后的每个键值对编码，最后加上e。在C#中，字典是不能排序的，在遍历Dictionary的时候，没有顺序的假设。因此我们把key排好序之后再遍历他们，获取他们的值。

## 种子

现在我们有了BEncoing解码器，我们现在回到之前的种子文件，然后把他解析为C#的数据格式

```C#
d
  8:announce            33:http://192.168.1.74:6969/announce
  7:comment             17:Comment goes here
  10:created by         25:Transmission/2.92 (14714)
  13:creation date      i1460444420e
  8:encoding            5:UTF-8
  4:info              
    d
      6:length          i59616e
      4:name            9:lorem.txt
      12:piece length   i32768e
      6:pieces          40:L@fR���3�K*Ez�>_YS��86��"�&�p�<�6�C{�9G
      7:private         i0e
    e
e
```

让我们一个个看看这些项并且决定如何存储

- announce：这个是我们需要追踪的url，可以是一个url也可以是一个url列表(List<Tracker>)
- comment：用户特殊的说明(string)
- created by：创建者(用户或者软件)(string)
- creation date：创建时间(DateTime)
- encoding：编码格式(System.Text.Encoding)
- info：我们希望分享的文件信息
  - length：文件按的大小(字节)(long)，一个种子可以包含一个或者多个文件，因此使用List<FileItem>
  - name：文件名(string)
  - piece length：文件块的大小(字节)通常是2的倍数(int)
  - pieces：由每一块生成的一个长度为20的SHA1字符串，连在一起变成一个大的字节数组(byte[][])
  - private：文件是否是私人的(bool)

## 数据结构

我们来创建一个简单的类来表示这些信息

上面有提到两个帮助的类，第一个是FileItem，它存储每个文件的路径、大小、偏移量(即这个文件之前的文件大小总和)

```c#
public class FileItem
{            
    public string Path;
    public long Size;
    public long Offset;

    public string FormattedSize { get { return Torrent.BytesToString(Size); } }
}
```

第二个帮助类是Tracker，用来保存url，我们之后会在这个类中加更多的功能以便和tracker保持通信。

```c#
public class Tracker
{
    public event EventHandler<List<IPEndPoint>> PeerListUpdated;

    public string Address { get; private set; }

    public Tracker(string address)
    {
        Address = address;
    }
}
```

### 哈希

种子文件还需要另一块数据，一般称之为哈希值。这是一个种子文件info部分的字节SHA1哈希，用来标识种子。我们也增添了一些其他属性用来把infohash转化为16进制字符以及通过HTTP与tracker通信的时候所需要的版本

```c#
public byte[] Infohash { get; private set; } = new byte[20];
public string HexStringInfohash { get { return String.Join("", this.Infohash.Select(x => x.ToString("x2"))); } }
public string UrlSafeStringInfohash { get { return Encoding.UTF8.GetString(WebUtility.UrlEncodeToBytes(this.Infohash, 0, 20)); } }
```

### 片&块

种子文件中的文件放在列表中，被拆分为相同大小的片（最后一块可能会抛出异常）。可以通过字节的SHA1的哈希确认每片。

块是比片小的单元。片在传说的过程中可能太大因此传输的是更小的块。每块的大小不固定，因此我们的客户端可能传输不同打下的块给其他人。使用不同大小的块这点无关紧要因为每块由片的index，byte偏移量和长度确定。块只有在每片被验证的情况下请求或者发送，显然只有所有的块得到验证之后片才能得到验证。

我们增加一些变量和方法来保持追踪片和块在torrent中的大小和过程

```c#
public int BlockSize { get; private set; }
public int PieceSize { get; private set; }
public long TotalSize { get { return Files.Sum(x => x.Size); } }

public string FormattedPieceSize { get { return BytesToString(PieceSize); } }
public string FormattedTotalSize { get { return BytesToString(TotalSize); } }

public int PieceCount { get { return PieceHashes.Length; } }

public byte[][] PieceHashes { get; private set; }
public bool[] IsPieceVerified { get; private set; }
public bool[][] IsBlockAcquired { get; private set; }

public string VerifiedPiecesString { get { return String.Join("", IsPieceVerified.Select(x => x ? 1 : 0)); } }
public int VerifiedPieceCount { get { return IsPieceVerified.Count(x => x); } }
public double VerifiedRatio { get { return VerifiedPieceCount / (double)PieceCount; } }
public bool IsCompleted { get { return VerifiedPieceCount == PieceCount; } }
public bool IsStarted { get { return VerifiedPieceCount > 0; } }

public long Uploaded { get; set; } = 0;
public long Downloaded { get { return PieceSize * VerifiedPieceCount; } } // !! incorrect
public long Left { get { return TotalSize - Downloaded; } }

public int GetPieceSize(int piece)
{            
    if (piece == PieceCount - 1)
    { 
        int remainder = Convert.ToInt32(TotalSize % PieceSize);
        if (remainder != 0)
            return remainder;
    }

    return PieceSize;
}

public int GetBlockSize(int piece, int block)
{
    if (block == GetBlockCount(piece) - 1)
    {
        int remainder = Convert.ToInt32(GetPieceSize(piece) % BlockSize);
        if (remainder != 0)
            return remainder;
    }

    return BlockSize;
}

public int GetBlockCount(int piece)
{
    return Convert.ToInt32(Math.Ceiling(GetPieceSize(piece) / (double)BlockSize));
}
```

### 配置

Torrent类的构造函数需要种子文件信息部分的所有数据，它设置跟踪器，加载或者创建单个哈希块，验证下载进度

还有一个PeerListUpdated事件，每当跟踪器接收到更新的peer列表时，它就会被触发。

```C#
![files](D:\myDocuments\pics\files.png)public event EventHandler<List<IPEndPoint>> PeerListUpdated;

private object[] fileWriteLocks;
private static SHA1 sha1 = SHA1.Create();
  
public Torrent(string name, string location, List<FileItem> files, List<string> trackers, int pieceSize, byte[] pieceHashes = null, int blockSize = 16384, bool? isPrivate = false )
{       
    Name = name;
    DownloadDirectory = location;
    Files = files;
    fileWriteLocks = new object[Files.Count];
    for (int i = 0; i < this.Files.Count; i++)
        fileWriteLocks[i] = new object();   

    if (trackers != null)
    {
        foreach (string url in trackers)
        {
            Tracker tracker = new Tracker(url);
            Trackers.Add(tracker);
            tracker.PeerListUpdated += HandlePeerListUpdated;
        }
    }

    PieceSize = pieceSize;
    BlockSize = blockSize;
    IsPrivate = isPrivate;

    int count = Convert.ToInt32(Math.Ceiling(TotalSize / Convert.ToDouble(PieceSize)));

    PieceHashes = new byte[count][];
    IsPieceVerified = new bool[count];
    IsBlockAcquired = new bool[count][];

    for (int i = 0; i < PieceCount; i++)
        IsBlockAcquired[i] = new bool[GetBlockCount(i)];            

    if (pieceHashes == null)
    {
        // this is a new torrent so we have to create the hashes from the files                 
        for (int i = 0; i < PieceCount; i++)
            PieceHashes[i] = GetHash(i);
    }
    else
    {
        for (int i = 0; i < PieceCount; i++)
        {
            PieceHashes[i] = new byte[20];
            Buffer.BlockCopy(pieceHashes, i * 20, PieceHashes[i], 0, 20);
        }
    }

    object info = TorrentInfoToBEncodingObject(this);
    byte[] bytes =  BEncoding.Encode(info);
    Infohash = SHA1.Create().ComputeHash(bytes);

    for (int i = 0; i < PieceCount; i++)
        Verify(i);
}
```

### 读&写

根据下面的表格可以看到，片和块不在乎一个文件何时结束下一个文件还是开始。单个片中可以包含任意数量的文件。

![img](https://media.seanjoflynn.com/images/research/bittorrent/files.png)

我们的Read()和Write()方法只需要开始位置和字节长度。方法都很相似都是选择一个片然后计算出开始和结束的位置，然后循环读取或者写入。Read()方法加载文件的字节到buffer里面然后返回它。读方法将给予的byte[]分块然后将他们写到每个文件正确的位置。我们也加入了lock来防止同时写入一个文件。

```C#
public byte[] Read(long start, int length)
{
    long end = start + length;
    byte[] buffer = new byte[length];

    for (int i=0; i<Files.Count; i++)
    {                
        if ((start < Files[i].Offset && end < Files[i].Offset) ||
            (start > Files[i].Offset + Files[i].Size && end > Files[i].Offset + Files[i].Size))
            continue;

        string filePath = DownloadDirectory + Path.DirectorySeparatorChar + FileDirectory + Files[i].Path;

        if (!File.Exists(filePath))
            return null;

        long fstart = Math.Max(0, start - Files[i].Offset);
        long fend = Math.Min(end - Files[i].Offset, Files[i].Size);
        int flength = Convert.ToInt32(fend - fstart);
        int bstart = Math.Max(0, Convert.ToInt32(Files[i].Offset - start));

        using (Stream stream = new FileStream(filePath, FileMode.Open, FileAccess.Read, FileShare.ReadWrite))
        {                    
            stream.Seek(fstart, SeekOrigin.Begin);
            stream.Read(buffer, bstart, flength);
        }
    }

    return buffer;
}

public void Write(long start, byte[] bytes)
{
    long end = start + bytes.Length;

    for (int i = 0; i < Files.Count; i++)
    {                
        if ((start < Files[i].Offset && end < Files[i].Offset) ||
            (start > Files[i].Offset + Files[i].Size && end > Files[i].Offset + Files[i].Size))
            continue;

        string filePath = DownloadDirectory + Path.DirectorySeparatorChar + FileDirectory + Files[i].Path;

        string dir = Path.GetDirectoryName(filePath);
        if (!Directory.Exists(dir))
            Directory.CreateDirectory(dir);

        lock (fileWriteLocks[i])
        {
            using (Stream stream = new FileStream(filePath, FileMode.OpenOrCreate, FileAccess.ReadWrite))
            {
                long fstart = Math.Max(0, start - Files[i].Offset);
                long fend = Math.Min(end - Files[i].Offset, Files[i].Size);
                int flength = Convert.ToInt32(fend - fstart);
                int bstart = Math.Max(0, Convert.ToInt32(Files[i].Offset - start));

                stream.Seek(fstart, SeekOrigin.Begin);
                stream.Write(bytes, bstart, flength);
            }
        }
    }
}
```

下面是一写读写的帮助函数

```c#
public byte[] ReadPiece(int piece)
{
    return Read(piece * PieceSize, GetPieceSize(piece));
}

public byte[] ReadBlock(int piece, int offset, int length)
{
    return Read(piece * PieceSize + offset, length);
}

public void WriteBlock(int piece, int block, byte[] bytes)
{            
    Write(piece * PieceSize + block * BlockSize, bytes);
    IsBlockAcquired[piece][block] = true;
    Verify(piece);
}
```

每一片的验证都是间接的，一个很重要需要注意的事情就是如果我们获取了所有的块但是验证失败了，就要将这些块重置然后重更新获取他们

```C#
public event EventHandler<int> PieceVerified;
  
public void Verify(int piece)
{
    byte[] hash = GetHash(piece);

    bool isVerified = (hash != null && hash.SequenceEqual(PieceHashes[piece]));

    if (isVerified)
    {                
        IsPieceVerified[piece] = true;

        for (int j = 0; j < IsBlockAcquired[piece].Length; j++)
            IsBlockAcquired[piece][j] = true;

        var handler = PieceVerified;
        if (handler != null)
            handler(this, piece);

        return;
    }

    IsPieceVerified[piece] = false;

    // reload the entire piece
    if (IsBlockAcquired[piece].All(x => x))
    {
        for (int j = 0; j < IsBlockAcquired[piece].Length; j++)
            IsBlockAcquired[piece][j] = false;
    }
}

public byte[] GetHash(int piece)
{
    byte[] data = ReadPiece(piece);

    if (data == null)
        return null;            

    return sha1.ComputeHash(data);
}
```

### 导入&导出

加载和保存种子文件的方式很简单

```C#
public static Torrent LoadFromFile(string filePath, string downloadPath)
{
    object obj = BEncoding.DecodeFile(filePath);
    string name = Path.GetFileNameWithoutExtension(filePath);

    return BEncodingObjectToTorrent(obj, name, downloadPath);
}

public static void SaveToFile(Torrent torrent)
{
    object obj = TorrentToBEncodingObject(torrent);

    BEncoding.EncodeToFile(obj, torrent.Name + ".torrent");
}
```

将种子文件和BEncoding对象转换的工作是最为繁琐的。将信息部分编码的工作在TorrentInfoToBEncodingObject()方法中被拆分了这样我们就可以利用它生成infohashes

```c#
public static long DateTimeToUnixTimestamp( DateTime time )
{
    return Convert.ToInt64((DateTime.UtcNow.Subtract(new DateTime(1970, 1, 1))).TotalSeconds);
}

private static object TorrentToBEncodingObject(Torrent torrent)
{
    Dictionary<string,object> dict = new Dictionary<string, object>();

    if( torrent.Trackers.Count == 1 )
        dict["announce"] = Encoding.UTF8.GetBytes(torrent.Trackers[0].Address);
    else
        dict["announce"] = torrent.Trackers.Select(x => (object)Encoding.UTF8.GetBytes(x.Address)).ToList();
    dict["comment"] = Encoding.UTF8.GetBytes(torrent.Comment);
    dict["created by"] = Encoding.UTF8.GetBytes(torrent.CreatedBy);
    dict["creation date"] = DateTimeToUnixTimestamp(torrent.CreationDate);
    dict["encoding"] = Encoding.UTF8.GetBytes(Encoding.UTF8.WebName.ToUpper());
    dict["info"] = TorrentInfoToBEncodingObject(torrent);

    return dict;
}

private static object TorrentInfoToBEncodingObject(Torrent torrent)
{
    Dictionary<string,object> dict = new Dictionary<string, object>();

    dict["piece length"] = (long)torrent.PieceSize;
    byte[] pieces = new byte[20 * torrent.PieceCount];
    for (int i = 0; i < torrent.PieceCount; i++)
        Buffer.BlockCopy(torrent.PieceHashes[i], 0, pieces, i * 20, 20);
    dict["pieces"] = pieces;

    if (torrent.IsPrivate.HasValue)
        dict["private"] = torrent.IsPrivate.Value ? 1L : 0L;

    if (torrent.Files.Count == 1)
    {                
        dict["name"] = Encoding.UTF8.GetBytes(torrent.Files[0].Path);
        dict["length"] = torrent.Files[0].Size;
    }
    else
    {
        List<object> files = new List<object>();

        foreach (var f in torrent.Files)
        {
            Dictionary<string,object> fileDict = new Dictionary<string, object>();
            fileDict["path"] = f.Path.Split(Path.DirectorySeparatorChar).Select(x => (object)Encoding.UTF8.GetBytes(x)).ToList();
            fileDict["length"] = f.Size;
            files.Add(fileDict);
        }

        dict["files"] = files;
        dict["name"] = Encoding.UTF8.GetBytes(torrent.FileDirectory.Substring(0, torrent.FileDirectory.Length - 1));
    }

    return dict;
}
```

将BEncoding对象和种子文件转换

```c#
public static string DecodeUTF8String( object obj )
{
    byte[] bytes = obj as byte[];

    if (bytes == null)
        throw new Exception("unable to decode utf-8 string, object is not a byte array");

    return Encoding.UTF8.GetString(bytes);
}

public static DateTime UnixTimeStampToDateTime( double unixTimeStamp )
{
    // Unix timestamp is seconds past epoch
    System.DateTime dtDateTime = new DateTime(1970,1,1,0,0,0,0,System.DateTimeKind.Utc);
    dtDateTime = dtDateTime.AddSeconds( unixTimeStamp ).ToLocalTime();
    return dtDateTime;
}

private static Torrent BEncodingObjectToTorrent(object bencoding, string name, string downloadPath)
{
    Dictionary<string,object> obj = (Dictionary<string,object>)bencoding;

    if (obj == null)
        throw new Exception("not a torrent file");
    
    // !! handle list
    List<string> trackers = new List<string>();
    if (obj.ContainsKey("announce"))                
        trackers.Add(DecodeUTF8String(obj["announce"]));            

    if (!obj.ContainsKey("info"))
        throw new Exception("Missing info section");

    Dictionary<string,object> info = (Dictionary<string,object>)obj["info"];

    if (info == null)
        throw new Exception("error");

    List<FileItem> files = new List<FileItem>();

    if (info.ContainsKey("name") && info.ContainsKey("length"))
    {
        files.Add(new FileItem() {
            Path = DecodeUTF8String(info["name"]),
            Size = (long)info["length"]
        });
    }
    else if (info.ContainsKey("files"))
    {
        long running = 0;

        foreach (object item in (List<object>)info["files"])
        {
            var dict = item as Dictionary<string,object>;

            if (dict == null || !dict.ContainsKey("path") || !dict.ContainsKey("length") )
                throw new Exception("error: incorrect file specification");

            string path = String.Join(Path.DirectorySeparatorChar.ToString(), ((List<object>)dict["path"]).Select(x => DecodeUTF8String(x)));

            long size = (long)dict["length"];

            files.Add(new FileItem() {
                Path = path,
                Size = size,
                Offset = running
            });

            running += size;
        }
    }
    else
    {
        throw new Exception("error: no files specified in torrent");
    }
        
    if (!info.ContainsKey("piece length"))
        throw new Exception("error");
    int pieceSize = Convert.ToInt32(info["piece length"]);

    if (!info.ContainsKey("pieces"))
        throw new Exception("error");            
    byte[] pieceHashes = (byte[])info["pieces"];

    bool? isPrivate = null;
    if (info.ContainsKey("private"))
        isPrivate = ((long)info["private"]) == 1L;            
    
    Torrent torrent = new Torrent(name, downloadPath, files, trackers, pieceSize, pieceHashes, 16384, isPrivate );

    if (obj.ContainsKey("comment"))
        torrent.Comment = DecodeUTF8String(obj["comment"]);

    if (obj.ContainsKey("created by"))
        torrent.CreatedBy = DecodeUTF8String(obj["created by"]);

    if (obj.ContainsKey("creation date"))
        torrent.CreationDate = UnixTimeStampToDateTime(Convert.ToDouble(obj["creation date"]));

    if (obj.ContainsKey("encoding"))
        torrent.Encoding = Encoding.GetEncoding(DecodeUTF8String(obj["encoding"]));
    
    return torrent;
}
```

### 创建

如果我们想要创建我们自己的种子文件，我们可以使用Create()方法，可以传入单个文件路径或者目录

```c#
public static Torrent Create(string path, List<string> trackers = null, int pieceSize = 32768, string comment = "")
{
    string name = "";
    List<FileItem> files = new List<FileItem>();

    if (File.Exists(path))
    {
        name = Path.GetFileName(path);

        long size = new FileInfo(path).Length;
        files.Add(new FileItem()
            {
                Path = Path.GetFileName(path),
                Size = size
            });
    }
    else
    {
        name = path;
        string directory = path + Path.DirectorySeparatorChar;

        long running = 0;
        foreach (string file in Directory.EnumerateFiles(path, "*.*", SearchOption.AllDirectories))
        {
            string f = file.Substring(directory.Length);

            if (f.StartsWith("."))
                continue;

            long size = new FileInfo(file).Length;

            files.Add(new FileItem()
                {
                    Path = f,
                    Size = size,
                    Offset = running
                });
            
            running += size;
        }
    }

    Torrent torrent = new Torrent(name, "", files, trackers, pieceSize);
    torrent.Comment = comment;
    torrent.CreatedBy = "TestClient";
    torrent.CreationDate = DateTime.Now;
    torrent.Encoding = Encoding.UTF8;

    return torrent;
}
```

## 追踪器

一旦我们已经准备好了所有的种子信息，我们应该如何寻找对象去连接？我们连接到追踪器的原因有两个，一个是他可以提供一个可以立刻尝试连接的追踪器列表。其次他会把我们加入对象列表中这样之后的新对象可以获得我们的ip地址和相应的端口号。我们要也可以获取当前的文件进度告诉他，一边可以追踪种子和预下载者的数量

### 宣告

跟踪器的最基本版本就是具有单个节点的HTTP服务器，我们本地运行的opentracker使用http://localhost:6969/announce端点，我们需要在HTTP GET请求中加一些参数

- infohash：这是我们种子的哈希，任何影响url的原始字节都需要转义，由UrlSafeStringInfohash属性提供
- peer_id：一个20比特的字符串来验证。大部分客户端使用少量字符来验证程序和版本，随后跟着一些随机字符。我们打算使用随机的数字组成的字符串
- port：监听传入连接的端口
- uploaded：已经上传的的字节数
- downloaded：已经下载的字节数
- left：还剩余需要下载的字节数
- event：当前客户端的状态，started、paused 、stopped。这样追踪器就知道是否需要把我们从对象中加入或者移除
- compact：0或1代表返回compact对象列表，opentracker似乎只能在compact模式下运作

我们可以使用curl来测试request在我们构建之前

```shell
$ curl -v "http://192.168.1.74:6969/announce?info_hash=%3E%09%D0%1CHHCy%CF%27%F23%24%E1%7B%BDijbD&peer_id=76433642664923430920&port=56723&uploaded=0&downloaded=0&left=0&event=started&compact=1"
*   Trying 192.168.1.74...
* Connected to 192.168.1.74 (192.168.1.74) port 6969 (#0)
> GET /announce?info_hash=%3E%09%D0%1CHHCy%CF%27%F23%24%E1%7B%BDijbD&peer_id=76433642664923430920&port=56723&uploaded=0&downloaded=0&left=0&event=started&compact=1 HTTP/1.1
> Host: 192.168.1.74:6969
> User-Agent: curl/7.43.0
> Accept: */*
> 
< HTTP/1.1 200 OK
< Content-Type: text/plain
< Content-Length: 111
< 
* Connection #0 to host 192.168.1.74 left intact
d8:completei2e10:downloadedi0e10:incompletei1e8:intervali1769e12:min intervali884e5:peers18:??J??Jݓ??J??e
```

结果是BEncoded 对象，将其格式化

```shell
d
  8:complete        i2e
  10:downloaded     i0e
  10:incomplete     i1e
  8:interval        i1769e
  12:min interval   i884e
  5:peers           18:??J??Jݓ??J??
e
```

一个个看reponse

- complete：拥有完整文件的对象数量
- downloaded：没有找到相关资料
- incomplete：没有完整文件的对象数量（预下载者）
- interval：客户端从追踪器请求更新对象列表的频率
- min interval：客户端从追踪器请求更新对象列表的最小频率
- peers：在紧凑模式下，是一个byte[]。每6个字节就是一个对象-前四个数字代表IPV4的地址，最后两个代表端口号

让我们在自己的代码中重现这些功能，首先为事件类型创建一个简单的枚举类

```c#
public enum TrackerEvent
{
    Started,
    Paused,
    Stopped
}
```

我们重新看Tracker类并且加入announcing的逻辑。我们的Update()方法创造需要的url。我增加了一个检查来防止过于频繁的检查新的对象。我们还需要一个方法来重置时钟

```c#
public DateTime LastPeerRequest { get; private set; } = DateTime.MinValue;
public TimeSpan PeerRequestInterval { get; private set; } = TimeSpan.FromMinutes(30);

public void Update(Torrent torrent, TrackerEvent ev, string id, int port)
{
    // wait until after request interval has elapsed before asking for new peers
    if (ev == TrackerEvent.Started && DateTime.UtcNow < LastPeerRequest.Add(PeerRequestInterval))
        return;

    LastPeerRequest = DateTime.UtcNow;

    string url = String.Format("{0}?info_hash={1}&peer_id={2}&port={3}&uploaded={4}&downloaded={5}&left={6}&event={7}&compact=1", 
                     Address, torrent.UrlSafeStringInfohash,
                     id, port,
                     torrent.Uploaded, torrent.Downloaded, torrent.Left, 
                     Enum.GetName(typeof(TrackerEvent), ev).ToLower());
    
    Request(url);
}

public void ResetLastRequest()
{
    LastPeerRequest = DateTime.MinValue;
}
```

Request()方法创建真正的HTTP 请求。HttpWebResponse.BeginGetResponse是异步的因此不会阻塞线程。我们可以简单指定一个回调函数(HandleResponse)当追踪器获得回复的时候获取值。我们读取返回的字节，并用BEncoding.Decode()处理。最后，我们解析时间间隔和对象列表来触发PeerListUpdated事件

```c#
private void Request( string url )
{
    httpWebRequest = (HttpWebRequest)HttpWebRequest.Create(url);
    httpWebRequest.BeginGetResponse(HandleResponse, null);
}

private void HandleResponse(IAsyncResult result)
{
    byte[] data;

    using (HttpWebResponse response = (HttpWebResponse)httpWebRequest.EndGetResponse(result))
    {
        if (response.StatusCode != HttpStatusCode.OK)
        {
            Console.WriteLine("error reaching tracker " + this + ": " + response.StatusCode + " " + response.StatusDescription);
            return;
        }
    
        using (Stream stream = response.GetResponseStream())
        {
            data = new byte[response.ContentLength];
            stream.Read(data, 0, Convert.ToInt32(response.ContentLength));
        }
    }

    Dictionary<string,object> info = BEncoding.Decode(data) as Dictionary<string,object>;

    if (info == null)
    {
        Console.WriteLine("unable to decode tracker announce response");
        return;
    }

    PeerRequestInterval = TimeSpan.FromSeconds((long)info["interval"]);
    byte[] peerInfo = (byte[])info["peers"];
        
    List<IPEndPoint> peers = new List<IPEndPoint>();
    for (int i = 0; i < peerInfo.Length/6; i++)
    {
        int offset = i * 6;
        string address = peerInfo[offset] + "." + peerInfo[offset+1] + "." + peerInfo[offset+2] + "." + peerInfo[offset+3];
        int port = EndianBitConverter.Big.ToChar(peerInfo, offset + 4);

        peers.Add(new IPEndPoint(IPAddress.Parse(address), port));
    }

    var handler = PeerListUpdated;
    if (handler != null)
        handler(this, peers);
}
```

这些就是Tracker类中的内容，我们将会继续在Torrent类中更新其中所有的追踪器

```c#
public void UpdateTrackers(TrackerEvent ev, string id, int port)
{
    foreach (var tracker in Trackers)
        tracker.Update(this, ev, id, port);
}

public void ResetTrackersLastUpdated()
{}
```

